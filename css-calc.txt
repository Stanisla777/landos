<template lang="pug">
  .calc-tax-deduc-new__container-block.js--calc-row-input
    .calc-tax-deduc-new__col-input.js--credit-calendar-input.js--tex-deduc-input.js--for-clear-field.js--calendar-data
      input.property-calculator__value.js--calendar-field.js--mobile-calendar-shedule(
        type="text"
        placeholder="ММ.ГГГГ"
        inputmode="numeric"
        @keyup="fieldNotEmpty"
        @input="changeDate"
        @click="showCalendar"
        @blur="inputBlur"
        @focus="replaceMonthFocus"
        @keydown="inputKeyDown"
      )
      .js__vanilla-calendar-calc.vanilla-calendar-style-new.property-calculator__vanilla-calendar.js-calendar-mobile-shedule(
        @click.stop="showCalendar"
      )
      .mor-rep-calculators__calendar-container-icon
        .calc-tax-deduc-new__input-clear.js--clear-calc-tax(
          @click="clearInputCalendar"
        )
        .property-calculator__input-additional-elem(
          @click="showCalendar"
        )
          svg(width='16', height='16', viewbox='0 0 16 16', fill='none', xmlns='http://www.w3.org/2000/svg')
            path(fill-rule='evenodd', clip-rule='evenodd', d='M4.66699 0.666687C5.03518 0.666687 5.33366 0.965164 5.33366 1.33335V2.00002H10.667V1.33335C10.667 0.965164 10.9655 0.666687 11.3337 0.666687C11.7018 0.666687 12.0003 0.965164 12.0003 1.33335V2.00002H14.0609C14.696 2.00002 15.3337 2.47837 15.3337 3.21214V14.1212C15.3337 14.855 14.696 15.3334 14.0609 15.3334H1.93972C1.30462 15.3334 0.666992 14.855 0.666992 14.1212V3.21214C0.666992 2.47837 1.30462 2.00002 1.93972 2.00002H4.00033V1.33335C4.00033 0.965164 4.2988 0.666687 4.66699 0.666687ZM4.00033 3.33335H2.00033V6.00002H14.0003V3.33335H12.0003V4.00002C12.0003 4.36821 11.7018 4.66669 11.3337 4.66669C10.9655 4.66669 10.667 4.36821 10.667 4.00002V3.33335H5.33366V4.00002C5.33366 4.36821 5.03518 4.66669 4.66699 4.66669C4.2988 4.66669 4.00033 4.36821 4.00033 4.00002V3.33335ZM14.0003 7.33335H2.00033V14H14.0003V7.33335Z', fill='#252628')
</template>

<script>
import eventBus from '../development-tools/eventBus.vue';
import Storage from '../development-tools/state.vue';
import VanillaCalendar from '../../vanilla-calendar2';
import numberFormatting from '../mixin/numberFormatting.js';

export default {
  name: 'v-2-component-calendar',
  mixins: [numberFormatting],
  data() {
    return {
      calendarMobile: null,
      parent: null,
      month: ["январь", "февраль", "март", "апрель", "май", "июнь", "июль", "август", "сентябрь", "октябрь", "ноябрь", "декабрь"],
      minDate: { month: 1, year: 1995 },
      maxDate: { month: 12, year: 2026 }
    };
  },
  methods: {
    initPluginCalendarVanilla(month = this.formatMonth(this.min_date_mobile), year = this.formatYear(this.min_date_mobile)) {
      const key_word_this = this;
      const range = {
        min: key_word_this.formatYearMonthMinDate(key_word_this.min_date_mobile),
        max: key_word_this.formatYearMonthMaxDate(key_word_this.min_date_mobile)
      };

      const element = document.querySelector('.js-calendar-mobile-shedule');
      if (element !== null) {
        this.parent = element.closest('.js--container-block');

        // Уничтожаем старый экземпляр
        if (this.calendarMobile) {
          this.calendarMobile.destroy();
        }

        this.calendarMobile = new VanillaCalendar('.js-calendar-mobile-shedule', {
          type: 'year',
          settings: {
            lang: 'ru',
            range: range,
            selected: {
              month: month,
              year: year
            },
          },
          actions: {
            clickMonth(e, dates) {
              if (dates.length !== 0) {
                const parent = e.target.closest('.js--credit-calendar-input');
                const container = e.target.closest('.js__vanilla-calendar-calc');
                const array_month = ['январь', 'февраль', 'март', 'апрель', 'май', 'июнь', 'июль', 'август', 'сентябрь', 'октябрь', 'ноябрь', 'декабрь'];
                
                let title_year = '';
                if (container) {
                  const yearElement = container.querySelector('.vanilla-calendar-year');
                  if (yearElement) {
                    title_year = yearElement.textContent;
                  }
                }

                if (parent) {
                  container.classList.remove('active');
                  const input = parent.querySelector('input');
                  if (input) {
                    input.value = `${array_month[dates.selectedMonth]}, ${dates.selectedYear}`;
                  }
                  const clearBtnParent = parent.closest('.js--calc-row-input');
                  if (clearBtnParent) {
                    const clearBtn = clearBtnParent.querySelector('.js--clear-calc-tax');
                    if (clearBtn) {
                      clearBtn.classList.add('active');
                    }
                  }
                }

                key_word_this.$emit('sendDateMobile', [dates.selectedYear, parseInt(dates.selectedMonth) + 1]);
              }
            },
            clickYear(e, dates) {
              let isClicked = false;
              const observer = new MutationObserver((mutations) => {
                for (const mutation of mutations) {
                  const targetElement = document.querySelector('.js-calendar-mobile-shedule .vanilla-calendar-header__content .vanilla-calendar-month');
                  if (targetElement && !isClicked) {
                    targetElement.click();
                    isClicked = true;
                    observer.disconnect();
                    break;
                  }
                }
              });
              observer.observe(document.body, { childList: true, subtree: true });
            }
          }
        });

        this.calendarMobile.init();

        // После инициализации — отключаем месяцы
        this.$nextTick(() => {
          setTimeout(() => this.disableOutOfRangeMonths(), 100);
        });
      }
    },

    disableOutOfRangeMonths() {
      const calendarContainer = document.querySelector('.js-calendar-mobile-shedule');
      if (!calendarContainer) return;

      const checkAndDisable = () => {
        const monthElems = calendarContainer.querySelectorAll('.vanilla-calendar-month');
        const yearElem = calendarContainer.querySelector('.vanilla-calendar-year');
        if (monthElems.length === 0 || !yearElem) {
          setTimeout(checkAndDisable, 50);
          return;
        }

        const displayYearText = yearElem.textContent.trim();
        const displayYear = parseInt(displayYearText, 10);
        if (isNaN(displayYear)) return;

        const minDate = new Date(this.minDate.year, this.minDate.month - 1);
        const maxDate = new Date(this.maxDate.year, this.maxDate.month - 1);

        monthElems.forEach((el, index) => {
          const monthIndex = index;
          const testDate = new Date(displayYear, monthIndex);

          const isOutOfRange = testDate < minDate || testDate > maxDate;

          if (isOutOfRange) {
            el.style.pointerEvents = 'none';
            el.style.opacity = '0.4';
            el.style.cursor = 'not-allowed';
            el.classList.add('disabled-by-range');
          } else {
            el.style.pointerEvents = '';
            el.style.opacity = '';
            el.style.cursor = '';
            el.classList.remove('disabled-by-range');
          }
        });
      };

      checkAndDisable();
    },

    showCalendar(el) {
      const element = el.currentTarget;
      document.querySelectorAll('.js__vanilla-calendar-calc').forEach(item => {
        item.classList.remove('active');
      });

      const parent = element.closest('.js--credit-calendar-input');
      if (!parent) return;

      const calendarBlock = parent.querySelector('.js__vanilla-calendar-calc');
      if (calendarBlock) {
        calendarBlock.classList.add('active');
      }

      this.$nextTick(() => {
        setTimeout(() => this.disableOutOfRangeMonths(), 100);
      });
    },

    CalendarVanillaClose() {
      let count = 0;
      document.body.onclick = () => {
        const array_parent = document.querySelectorAll('.js--credit-calendar-input');
        const array_element = document.querySelectorAll('.js__vanilla-calendar-calc.active');

        array_parent.forEach(item => {
          item.onclick = (w) => w.stopImmediatePropagation();
        });

        if (count > 0) {
          array_element.forEach(el => el.classList.remove('active'));
        }
        count++;
      };
    },

    fieldNotEmpty(e) {
      const element = e.currentTarget || e;
      const parent = element.closest('.js--calc-row-input');
      if (parent && element.value.length > 0) {
        const clearBtn = parent.querySelector('.js--clear-calc-tax');
        if (clearBtn) {
          clearBtn.classList.add('active');
        }
      } else {
        const clearBtn = parent && parent.querySelector('.js--clear-calc-tax');
        if (clearBtn) {
          clearBtn.classList.remove('active');
        }
      }
    },

    clearInputCalendar(e) {
      const element = e.currentTarget;
      const parent = element.closest('.js--tex-deduc-input');
      if (parent) {
        const input = parent.querySelector('input');
        if (input) {
          input.value = '';
          input.classList.remove('active');
        }
        element.classList.remove('active');
      }
    },

    changeDate(e) {
      const target = e.target;
      let value = target.value.replace(/[^\d.]/g, '');
      const parts = value.split('.');
      let monthPart = parts[0] ? parts[0].substring(0, 2) : '';
      let yearPart = parts[1] ? parts[1].substring(0, 4) : '';

      let newValue = monthPart;
      if (monthPart.length >= 2 || yearPart.length > 0) {
        newValue += '.' + yearPart;
      }

      if (newValue !== target.value) {
        const cursorPos = target.selectionStart;
        target.value = newValue;
        target.setSelectionRange(cursorPos, cursorPos);
      }

      if (target.value.length === 3 && newValue[2] === '.') {
        target.setSelectionRange(3, 3);
      }

      if (target.value.replace(/(_|\s)+/g, "").length === 7) {
        let [monthStr, yearStr] = e.target.value.split('.');
        let month = parseInt(monthStr, 10) || 0;
        let year = parseInt(yearStr, 10) || 0;

        if (month < 1) month = 1;
        if (month > 12) month = 12;

        if (year < this.minDate.year) {
          year = this.minDate.year;
          month = this.minDate.month;
        } else if (year > this.maxDate.year) {
          year = this.maxDate.year;
          month = this.maxDate.month;
        }

        if (year === this.minDate.year) month = Math.max(month, this.minDate.month);
        if (year === this.maxDate.year) month = Math.min(month, this.maxDate.month);

        const current = { month, year };
        const currentNum = this.dateToNumber(current);
        const minNum = this.dateToNumber(this.minDate);
        const maxNum = this.dateToNumber(this.maxDate);

        if (currentNum < minNum) Object.assign(current, this.minDate);
        if (currentNum > maxNum) Object.assign(current, this.maxDate);

        e.target.value = this.formatDate(current.month, current.year);
        setTimeout(() => {
          this.$emit('sendDateMobile', [current.year, current.month]);
        }, 400);
      }
    },

    formatMonth(dateStr) {
      if (!dateStr) return 1;
      const parts = dateStr.split('-');
      if (parts.length < 2) return 1;
      const month = parseInt(parts[1], 10);
      return isNaN(month) ? 1 : month;
    },

    formatYear(dateStr) {
      if (!dateStr) return new Date().getFullYear();
      const year = dateStr.split('-')[0];
      const num = parseInt(year, 10);
      return isNaN(num) ? new Date().getFullYear() : num;
    },

    formatYearMonthMinDate(dateStr) {
      if (!dateStr) return '';
      const parts = dateStr.split('-');
      if (parts.length < 2) return '';
      const year = parseInt(parts[0], 10);
      const month = parseInt(parts[1], 10);
      if (isNaN(year) || isNaN(month)) return '';
      const date = new Date(year, month - 1);
      date.setMonth(date.getMonth() + 1);
      const m = (date.getMonth() + 1).toString().padStart(2, '0');
      return `${date.getFullYear()}-${m}`;
    },

    formatYearMonthMaxDate(dateStr) {
      if (this.loanTerm === 0) return `${new Date().getFullYear() + 1}-12`;
      const parts = dateStr.split('-');
      if (parts.length < 2) return '';
      const year = parseInt(parts[0], 10);
      const month = parseInt(parts[1], 10);
      if (isNaN(year) || isNaN(month)) return '';
      const date = new Date(year, month - 1);
      date.setMonth(date.getMonth() + 1 + this.loanTerm);
      const m = (date.getMonth() + 1).toString().padStart(2, '0');
      return `${date.getFullYear()}-${m}`;
    },

    formatDate(month, year) {
      return `${String(month).padStart(2, '0')}.${String(year).padStart(4, '0')}`;
    },

    dateToNumber(date) {
      return date.year * 12 + (date.month - 1);
    },

    inputBlur(e) {
      const target = e.target;
      const parts = target.value.split('.');
      if (!parts[0] || !parts[1] || parts[0].length !== 2 || parts[1].length !== 4) {
        target.value = '';
      }
      this.replaceMonth(target);
    },

    replaceMonth(e) {
      const element = e.currentTarget || e;
      const value = element.value.trim();
      const parts = value.split('.');
      if (parts.length !== 2) return;
      const monthNumber = parseInt(parts[0], 10);
      if (isNaN(monthNumber) || monthNumber < 1 || monthNumber > 12) return;
      element.value = `${this.month[monthNumber - 1]}, ${parts[1]}`;
    },

    replaceMonthFocus(e) {
      const element = e.currentTarget || e;
      const currentValue = element.value;
      const parts = currentValue.split(', ');
      if (parts.length === 2) {
        const monthName = parts[0];
        const year = parts[1];
        const monthIndex = this.month.indexOf(monthName);
        if (monthIndex !== -1 && year && year.length === 4) {
          element.value = `${String(monthIndex + 1).padStart(2, '0')}.${year}`;
        }
      }
    },

    inputKeyDown(e) {
      if (e.key === 'Backspace' && e.target.selectionStart === 3) {
        e.target.setSelectionRange(2, 2);
      }
    }
  },
  computed: {
    loanTerm() {
      return Storage.getters.TIMECREDIT;
    },
    min_date_mobile() {
      return Storage.getters.MINDATEMOBILE;
    }
  },
  watch: {
    min_date_mobile() {
      this.initPluginCalendarVanilla();
      this.CalendarVanillaClose();

      const minDateStr = this.formatYearMonthMinDate(this.min_date_mobile);
      const maxDateStr = this.formatYearMonthMaxDate(this.min_date_mobile);

      if (minDateStr) {
        const [year, month] = minDateStr.split('-');
        this.minDate = {
          month: parseInt(month, 10),
          year: parseInt(year, 10)
        };
      }

      if (maxDateStr) {
        const [yearMax, monthMax] = maxDateStr.split('-');
        this.maxDate = {
          month: parseInt(monthMax, 10),
          year: parseInt(yearMax, 10)
        };
      }
    },
    loanTerm() {
      this.initPluginCalendarVanilla();
      this.CalendarVanillaClose();

      const minDateStr = this.formatYearMonthMinDate(this.min_date_mobile);
      const maxDateStr = this.formatYearMonthMaxDate(this.min_date_mobile);

      if (minDateStr) {
        const [year, month] = minDateStr.split('-');
        this.minDate = {
          month: parseInt(month, 10),
          year: parseInt(year, 10)
        };
      }

      if (maxDateStr) {
        const [yearMax, monthMax] = maxDateStr.split('-');
        this.maxDate = {
          month: parseInt(monthMax, 10),
          year: parseInt(yearMax, 10)
        };
      }
    }
  },
  mounted() {
    this.CalendarVanillaClose();
  },
  created() {
    const minDateStr = this.formatYearMonthMinDate(this.min_date_mobile);
    const maxDateStr = this.formatYearMonthMaxDate(this.min_date_mobile);

    if (minDateStr) {
      const [year, month] = minDateStr.split('-');
      this.minDate = {
        month: parseInt(month, 10),
        year: parseInt(year, 10)
      };
    }

    if (maxDateStr) {
      const [yearMax, monthMax] = maxDateStr.split('-');
      this.maxDate = {
        month: parseInt(monthMax, 10),
        year: parseInt(yearMax, 10)
      };
    }
  }
};
</script>
