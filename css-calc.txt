export default {
  name: 'EventCalendar',
  data() {
    return {
      currentMonth: null, // будет вычислено
      currentYear: null,  // будет вычислено
      selectedDate: null,
      events: [],
      minDate: null, // { year, month }
      maxDate: null, // { year, month }
    };
  },
  computed: {
    weekdays() {
      return ['Пн', 'Вт', 'Ср', 'Чт', 'Пт', 'Сб', 'Вс'];
    },
    currentMonthName() {
      const months = [
        'Январь', 'Февраль', 'Март', 'Апрель', 'Май', 'Июнь',
        'Июль', 'Август', 'Сентябрь', 'Октябрь', 'Ноябрь', 'Декабрь'
      ];
      return months[this.currentMonth];
    },
    daysInMonth() {
      const days = [];
      const firstDay = new Date(this.currentYear, this.currentMonth, 1).getDay(); // 0 = воскресенье
      const daysInMonth = new Date(this.currentYear, this.currentMonth + 1, 0).getDate();

      // Пустые ячейки до первого дня месяца
      for (let i = 0; i < (firstDay === 0 ? 6 : firstDay - 1); i++) {
        days.push({ number: '', date: null, hasEvents: false });
      }

      // Ячейки с днями месяца
      for (let day = 1; day <= daysInMonth; day++) {
        const dateStr = this.formatDateForData(new Date(this.currentYear, this.currentMonth, day));
        const normalizedDateStr = this.normalizeDate(dateStr); // для сравнения
        const dayEvents = this.events.find(e => this.normalizeDate(e.date) === normalizedDateStr);
        days.push({
          number: day,
          date: dateStr, // сохраняем в формате DD.MM.YYYY для отображения
          hasEvents: !!dayEvents
        });
      }

      return days;
    },
    eventsForSelectedDay() {
      if (!this.selectedDate) return [];
      const normalizedSelected = this.normalizeDate(this.selectedDate);
      const dayData = this.events.find(e => this.normalizeDate(e.date) === normalizedSelected);
      return dayData ? dayData.type : [];
    },
    canGoPrev() {
      if (!this.minDate) return false;
      const current = this.currentYear * 12 + this.currentMonth;
      const min = this.minDate.year * 12 + this.minDate.month;
      return current > min;
    },
    canGoNext() {
      if (!this.maxDate) return false;
      const current = this.currentYear * 12 + this.currentMonth;
      const max = this.maxDate.year * 12 + this.maxDate.month;
      return current < max;
    }
  },
  mounted() {
    this.parseEvents();
    this.calculateDateBounds(); // 1. Определяем границы
    this.setDefaultMonth();     // 2. Устанавливаем стартовый месяц
    this.setDefaultSelection(); // 3. Выбираем день
  },
  methods: {
    parseEvents() {
      const eventAttr = this.$el.parentElement.getAttribute('data-event');
      if (!eventAttr) return;
      try {
        this.events = JSON.parse(eventAttr);
      } catch (e) {
        console.error('Ошибка парсинга data-event', e);
      }
    },

    // Нормализация даты: "5.10.2025" → "05.10.2025"
    normalizeDate(dateStr) {
      if (!dateStr) return '';
      const [d, m, y] = dateStr.split('.');
      const dd = String(parseInt(d, 10)).padStart(2, '0');
      const mm = String(parseInt(m, 10)).padStart(2, '0');
      return `${dd}.${mm}.${y}`;
    },

    formatDateForData(date) {
      const d = String(date.getDate()).padStart(2, '0');
      const m = String(date.getMonth() + 1).padStart(2, '0');
      const y = date.getFullYear();
      return `${d}.${m}.${y}`;
    },

    formatDate(dateStr) {
      return dateStr;
    },

    getEventTypes(dateStr) {
      const normalized = this.normalizeDate(dateStr);
      const day = this.events.find(e => this.normalizeDate(e.date) === normalized);
      if (!day) return [];
      return day.type.map(item => Object.keys(item)[0]);
    },

    getEventTitle(eventObj) {
      const key = Object.keys(eventObj)[0];
      const map = {
        kefir: 'Эфир',
        rozigrish: 'Розыгрыш',
        test: 'Тестирование'
      };
      return map[key] || key;
    },

    getEventDescription(eventObj) {
      const key = Object.keys(eventObj)[0];
      return eventObj[key];
    },

    selectDay(day) {
      if (!day.hasEvents) return;
      this.selectedDate = day.date;
    },

    isSelected(dateStr) {
      if (!this.selectedDate || !dateStr) return false;
      return this.normalizeDate(this.selectedDate) === this.normalizeDate(dateStr);
    },

    parseDate(dateStr) {
      const normalized = this.normalizeDate(dateStr);
      const [d, m, y] = normalized.split('.').map(Number);
      return new Date(y, m - 1, d);
    },

    // 1. Вычисляем границы — первый и последний месяц с событиями
    calculateDateBounds() {
      if (this.events.length === 0) {
        const now = new Date();
        this.minDate = this.maxDate = { year: now.getFullYear(), month: now.getMonth() };
        return;
      }

      const dates = this.events.map(e => this.parseDate(e.date));
      const minDate = new Date(Math.min(...dates));
      const maxDate = new Date(Math.max(...dates));

      this.minDate = { year: minDate.getFullYear(), month: minDate.getMonth() };
      this.maxDate = { year: maxDate.getFullYear(), month: maxDate.getMonth() };
    },

    // 2. Устанавливаем начальный месяц — ближайший месяц с будущим событием
    setDefaultMonth() {
      const now = new Date();

      // Ищем ближайшее будущее событие (включая сегодня)
      const futureEvents = this.events
        .map(e => ({ ...e, dateObj: this.parseDate(e.date) }))
        .filter(e => e.dateObj >= now)
        .sort((a, b) => a.dateObj - b.dateObj);

      if (futureEvents.length > 0) {
        const targetDate = futureEvents[0].dateObj;
        this.currentYear = targetDate.getFullYear();
        this.currentMonth = targetDate.getMonth();
        return;
      }

      // Если будущих нет — последнее событие
      const pastEvents = this.events
        .map(e => ({ ...e, dateObj: this.parseDate(e.date) }))
        .sort((a, b) => b.dateObj - a.dateObj);

      if (pastEvents.length > 0) {
        const targetDate = pastEvents[0].dateObj;
        this.currentYear = targetDate.getFullYear();
        this.currentMonth = targetDate.getMonth();
        return;
      }

      // fallback
      this.currentYear = now.getFullYear();
      this.currentMonth = now.getMonth();
    },

    // 3. Устанавливаем выбранный день — ТОЛЬКО ближайший будущий (не прошедший!)
    setDefaultSelection() {
      const now = new Date();

      // Только будущие события (>= сегодня)
      const futureEvents = this.events
        .filter(e => this.parseDate(e.date) >= now)
        .sort((a, b) => this.parseDate(a.date) - this.parseDate(b.date));

      if (futureEvents.length > 0) {
        this.selectedDate = futureEvents[0].date;
        return;
      }

      // Если будущих нет — последнее прошедшее
      const pastEvents = this.events
        .filter(e => this.parseDate(e.date) < now)
        .sort((a, b) => this.parseDate(b.date) - this.parseDate(a.date));

      if (pastEvents.length > 0) {
        this.selectedDate = pastEvents[0].date;
        return;
      }

      this.selectedDate = null;
    },

    // 4. Переключение месяцев — с ограничениями
    prevMonth() {
      if (!this.canGoPrev) return;

      if (this.currentMonth === 0) {
        this.currentMonth = 11;
        this.currentYear--;
      } else {
        this.currentMonth--;
      }

      // НЕ вызываем setDefaultSelection — пользователь сам выбирает день
      // this.setDefaultSelection(); ← УБРАЛИ!
    },

    nextMonth() {
      if (!this.canGoNext) return;

      if (this.currentMonth === 11) {
        this.currentMonth = 0;
        this.currentYear++;
      } else {
        this.currentMonth++;
      }

      // НЕ вызываем setDefaultSelection — пользователь сам выбирает день
      // this.setDefaultSelection(); ← УБРАЛИ!
    }
  }
};



<button @click="prevMonth" :disabled="!canGoPrev">←</button>
<button @click="nextMonth" :disabled="!canGoNext">→</button>


Что если хочешь запретить выбор прошлых дат?

Тогда нужно добавить проверку:

selectDay(day) {
  if (!day.hasEvents) return;

  const eventDate = this.parseDate(day.date);
  const now = new Date();
  now.setHours(0, 0, 0, 0); // обнуляем время для корректного сравнения

  // Если хочешь запретить выбор прошлых дат — раскомментируй:
  // if (eventDate < now) return;

  this.selectedDate = day.date;
}
