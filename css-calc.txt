receivedDateMobile([year, month]) {
      const dateString = `${year}-${month}`;
      this.$nextTick(() => {
        const element = this.$refs.mobileShedule.querySelector(`[data-date="${dateString}"]`);
        if (element) {
          this.smoothScrollToElement(element);
        }
      });
    },

    async smoothScrollToElement(element) {
      const container = this.$refs.mobileShedule;

      // Вычисляем все необходимые позиции
      const elementRect = element.getBoundingClientRect();
      const containerRect = container.getBoundingClientRect();

      // Вычисляем конечную позицию скролла внутри контейнера
      const relativeTop = elementRect.top - containerRect.top;
      const targetContainerScroll = container.scrollTop + relativeTop - 20;

      // Проверяем, виден ли элемент в контейнере
      const isElementVisibleInContainer =
        relativeTop >= 0 &&
        (relativeTop + elementRect.height) <= containerRect.height;

      if (!isElementVisibleInContainer) {
        // Если элемент не виден в контейнере, скроллим контейнер
        await this.animateScroll(container, targetContainerScroll, 600);
      }

      // Теперь проверяем, виден ли контейнер в viewport
      const containerViewportPosition = container.getBoundingClientRect();
      const isContainerInViewport =
        containerViewportPosition.top >= 0 &&
        containerViewportPosition.bottom <= (window.innerHeight || document.documentElement.clientHeight);

      if (!isContainerInViewport) {
        // Если контейнер не в viewport, скроллим страницу так, чтобы контейнер был виден
        const targetWindowScroll = window.scrollY + containerViewportPosition.top - 20;
        await this.animateScroll(window, targetWindowScroll, 600);
      }
    },

    isElementInViewport(el) {
      const rect = el.getBoundingClientRect();
      return (
        rect.top >= 0 &&
        rect.bottom <= (window.innerHeight || document.documentElement.clientHeight)
      );
    },

    animateScroll(element, targetPosition, duration) {
      return new Promise(resolve => {
        const startPosition = element.scrollTop || window.scrollY;
        const distance = targetPosition - startPosition;
        let startTime = null;

        const animation = (timestamp) => {
          if (!startTime) startTime = timestamp;
          const progress = timestamp - startTime;
          const percentage = Math.min(progress / duration, 1);

          // Кубическая easing функция для плавности
          const easing = t => t<.5 ? 4*t*t*t : (t-1)*(2*t-2)*(2*t-2)+1;
          const scrollNow = startPosition + (distance * easing(percentage));

          if (element === window) {
            window.scrollTo(0, scrollNow);
          } else {
            element.scrollTop = scrollNow;
          }

          if (progress < duration) {
            window.requestAnimationFrame(animation);
          } else {
            resolve();
          }
        };

        window.requestAnimationFrame(animation);
      });
    },
