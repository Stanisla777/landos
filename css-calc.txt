template
          component-tooltip(:tooltip="'data-monthly-payment'" :infoValue="shedule[0].payment" title-text="Ежемесячный платеж")


store => {
      store.watch(
        state => [state.loanAmount, state.annualInterestRate,state.loanTerm],
        ()=>{
          store.commit('mutationTotalCalculate')
          // store.commit('mutationTotalCalculate')
        },
        {deep:true}
      )
    }
  ],


<script>
import Vue from 'vue';
import Vuex from 'vuex';

Vue.use(Vuex);

let obj_month =["январь", "февраль", "март", "апрель", "май", "июнь", "июль", "август", "сентябрь", "октябрь", "ноябрь", "декабрь","январь", "февраль", "март", "апрель", "май", "июнь", "июль", "август", "сентябрь", "октябрь", "ноябрь", "декабрь"]
function calculateAnnuity(P, r ,n){
  if (r ===  0) return P /n;
  return (P * r) / (1 - Math.pow(1 + r, -n));
}

function calculateMortgageSheduleFirst(
  loanAmount,
  annualInterestRate,
  initialTermMonths,
  startDate,
  prepayments = []
) {
  const montlyRate = annualInterestRate /12 /100;
  let currentBalance = loanAmount;
  let currentPayment = calculateAnnuity(loanAmount, montlyRate, initialTermMonths);
  let remainingTerm = initialTermMonths;
  const shedule = [];

  const startDateNew = startDate.replace(/-(\d)$/, '-0$1')
  const [year,month] = startDateNew.split('-').map(Number)
  const currentDate = new Date(year, month - 1)
  currentDate.setMonth(currentDate.getMonth() +1);


  // const currentDate = new Date(startDate);
  // currentDate.setMonth(currentDate.getMonth() +1);

  while (currentBalance > 0 && remainingTerm > 0) {
    const currentMonth = currentDate.getMonth() + 1;
    const currentYear = currentDate.getFullYear();
    const interest = currentBalance * montlyRate;
    let principal = currentPayment - interest;
    let totalPayment = principal + interest;
    if (principal > currentBalance) {
      principal = currentBalance;
      totalPayment = principal + interest
    }
    const remainingBeforePrepayments = currentBalance - principal;
    const sheduleEntry = {
      month: currentMonth,
      year: currentYear,
      nameMonth:obj_month[currentMonth - 1],
      payment: totalPayment,
      principal: principal,
      interest: interest,
      remainingBalance: remainingBeforePrepayments,
      prepayments: []
    };
    currentBalance = remainingBeforePrepayments;
    shedule.push(sheduleEntry)
    currentDate.setMonth(currentDate.getMonth() + 1);
    remainingTerm--
  }
  return shedule
}
function payAllInterest(shedule) {
  return shedule.reduce((sum, item) => sum + item.interest,0)
}

export default new Vuex.Store({
  state:{
    //новое
    transfer_parametr:null, //параметры, которые приходят из атрибутов html
    transfer_tooltip:null, //все тултипы
    calculating_initial_payment_cost:true, //если true то первоначальный взнос может меняться, когда меняется стоимость, если false то при изменении стоимости первоначальный взнос меняться не будет
    initial_payment_from_cost:0, //первоначальный взнос рассчитанный от стоимости недвижимости умноженное на 0,2
    cost_property:0, //стоимость недвижимости
    initial_payment:0, //первоначальный взнос непосредственно когда меняется соответствующее поле
    loanAmount:0, //первоначальная сумма кредита (стоимость недвижимости - первоначальный взнос)
    recalculation_initial_payment:false, //От флага зависит делать перерасчёт первоначального взноса или нет
    annualInterestRate:0.1, //процентная ставка ипотеки
    loanTerm:0, //срок кредита
    modal_tooltip_attribute_data:null, //значение дата модалки, коорую открываем, чтобы определить, какой контент подставлять
    modal_tooltip_status:false, //true - модалка с тултипами открывается, false - модалка закрывается
    modal_mail_send_status:false, //true - модалка с отправкой почты открывается, false - модалка закрывается
    dateLoanReceipt:[], //дата начала кредита = равно текущая дата в виде массива [7,2025]

    startMonth:null, //месяц взятия кредита
    startYear:0,//год взятия кредита
    startMortage:'',
    startMortageDiff:'',
    min_date_mobile:`${new Date().getFullYear() - 30}-01-01`, //для календаря дата оформления кредита, коорый находится в графике платежей в мобилке
    shedule:[], // график платежей, который будет формироваться без досрочек и ипотечных каникул
    amount_taxes_paid:0, // сумма уплаченных налогов
    debt_interest:0, // основной долг + проценты
    tax_deduction_property:0, //имущественный вычет
    tax_deduction_interest:0, //вычет по процентам
    total_tax_deduction:0, // налоговый вычет имущественный вычет + вычет по процентам
    required_income:0, //необходимый налог



  },
  getters:{
    //новое
    TRANSFERPARAMETR(state){
      return state.transfer_parametr
    },
    TRANSFERTOOLTIP(state){
      return state.transfer_tooltip
    },

    INITIALPAYMENTFROMCOST(state){
      return state.initial_payment_from_cost
    },

    INITIALPAYMENT(state){
      return state.initial_payment
    },

    CALCULATINGINITIALPAYMENTCOST(state){
      return state.calculating_initial_payment_cost
    },
    RECALCULATIONINITIALPAYMENT(state){
      return state.recalculation_initial_payment
    },
    TIMECREDIT(state){
      return state.loanTerm
    },
    MODALTOOLTIPATTRIBUTEDATA(state){
      return state.modal_tooltip_attribute_data
    },
    MODALTOOLTIPSTATUS(state){
      return state.modal_tooltip_status
    },
    MODALMAILSENDSTATUS(state){
      return state.modal_mail_send_status
    },


    LOANAMOUNT(state){
      return state.loanAmount
    },
    ANNUALINTERESTRATE(state){
      return state.annualInterestRate
    },

    SHEDULE(state){
      return state.shedule
    },
    DEBTINTEREST(state){
      return state.debt_interest
    },
    TOTALTAXDEDUCTION(state){
      return state.total_tax_deduction
    },
    REQUIREDINCOME(state){
      return state.required_income
    },
    MINDATEMOBILE(state){
      return state.min_date_mobile
    },







  },

  mutations:{
    //новое

    mutationTransferParametr(state,received_perem){
      state.transfer_parametr = received_perem
    },

    mutationTransferTooltip(state,received_perem){
      state.transfer_tooltip = received_perem
    },



    mutationCostPropertyForInitialPayment(state,received_perem){
      state.initial_payment_from_cost = (received_perem * (state.transfer_parametr.initial_payment_perc / 100)).toFixed(0)
    },

    mutationCostProperty(state,received_perem){
      state.cost_property = received_perem
      if (parseInt(state.initial_payment) < parseInt(state.initial_payment_from_cost) || parseInt(state.initial_payment)>parseInt(state.cost_property)) {
        state.recalculation_initial_payment = true
      }
      else {
        state.recalculation_initial_payment = false
      }
      state.loanAmount = parseInt(state.cost_property) - parseInt(state.initial_payment) // рассчитал сумму кредита
    },
    mutationInitialPayment(state,received_perem){
      state.initial_payment = received_perem
      if (parseInt(state.initial_payment) < parseInt(state.initial_payment_from_cost)  || parseInt(state.initial_payment)>parseInt(state.cost_property)) {
        state.recalculation_initial_payment = true
      }
      else {
        state.recalculation_initial_payment = false
      }
      state.loanAmount = parseInt(state.cost_property) - parseInt(state.initial_payment) // рассчитал сумму кредита
    },

    mutationInitialPaymentIsChanged(state,received_perem){
      state.calculating_initial_payment_cost = received_perem
    },

    mutationInterestRate(state,received_perem){
      state.annualInterestRate = received_perem
    },
    mutationTimeCredit(state,received_perem){
      state.loanTerm = received_perem
    },
    mutationOpenModalStatus(state,received_perem){
      state.modal_tooltip_status = received_perem
    },
    mutationOpenModalMailStatus(state,received_perem){
      state.modal_mail_send_status = received_perem
    },

    mutationOpenModalTooltip(state,received_perem){
      state.modal_tooltip_attribute_data = received_perem
    },
    mutationDateBeginCredit(state,received_perem){
      state.dateLoanReceipt = received_perem
      state.startMonth=received_perem[0] + 1
      state.startYear=parseInt(received_perem[1])
      state.startMortage = `${received_perem[1]}-${received_perem[0]+1}`
      state.startMortageDiff = {month:state.startMonth +1, year:state.startYear}
      state.min_date_mobile = `${received_perem[1]}-${received_perem[0]}`
    },

    //итоговые расчёты
    mutationTotalCalculate(state){
      state.shedule = calculateMortgageSheduleFirst(
        state.loanAmount,state.annualInterestRate,state.loanTerm,state.startMortage,state.array_early_repayment
      )
      //сумма уплаченных налогов
      state.amount_taxes_paid = payAllInterest(state.shedule)
      //считаю основной долг + проценты уплаченные
      state.debt_interest = state.amount_taxes_paid + state.loanAmount

      //считаю налоговый вычет
      state.tax_deduction_property = state.loanAmount * 0.13
      if (state.tax_deduction_property > state.transfer_parametr.max_tax_deduction_property) {
        state.tax_deduction_property = state.transfer_parametr.max_tax_deduction_property
      }

      state.tax_deduction_interest = state.amount_taxes_paid * 0.13
      if (state.tax_deduction_interest > state.transfer_parametr.max_tax_deduction_interest) {
        state.tax_deduction_interest =  state.transfer_parametr.max_tax_deduction_interest
      }

      state.total_tax_deduction = state.tax_deduction_property + state.tax_deduction_interest

      //считаю необходимый доход
      state.required_income = state.shedule[0].payment / 0.5

    },
  },
  actions:{
    //новое

    //для расчёта первоначального взноса, когда меняется стоимость недвижимости - это первый мутатион, второй - это приходит стоимость недвижимости
    ActionTransferParametr({commit,state,dispatch},param){
      commit('mutationTransferParametr',param)
    },
    //получаю все тултипы
    ActionTransferTooltip({commit,state,dispatch},param){
      commit('mutationTransferTooltip',param)
    },



    //для расчёта первоначального взноса, когда меняется стоимость недвижимости - это первый мутатион, второй - это приходит стоимость недвижимости
    ActionCostProperty({commit,state,dispatch},param){
      commit('mutationCostPropertyForInitialPayment',param)
      commit('mutationCostProperty',param)
      // commit('mutationTotalCalculate')
    },

    //меняется первоначальный взнос непосредственно в поле
    ActionInitialPayment({commit,state,dispatch},param){
      commit('mutationInitialPayment',param)
    },

    //когда первоначальный взнос меняется пользователем и calculating_initial_payment_cost ставлю флаг false, чтобы он не менялся когда меняется стоимость жилья
    ActionInitialPaymentIsChanged({commit,state,dispatch},param){
      commit('mutationInitialPaymentIsChanged',param)
    },

    //процентная ставка
    ActionInterestRate({commit,state,dispatch},param){
      commit('mutationInterestRate',param)
    },

    //срок кредита в месяцах
    ActionTimeCredit({commit,state,dispatch},param){
      commit('mutationTimeCredit',param)
    },

    //открыть или закрыть модалку с тултипами(true или false)
    ActionOpenModalStatus({commit,state,dispatch},param){
      commit('mutationOpenModalStatus',param)
    },
    //открыть или закрыть модалку с отправкой почты(true или false)
    ActionOpenModalMailStatus({commit,state,dispatch},param){
      commit('mutationOpenModalMailStatus',param)
    },

    //открытие модального онка для тултипов, где много текста
    ActionOpenModalTooltip({commit,state,dispatch},param){
      commit('mutationOpenModalTooltip',param)
    },
    //открытие модального онка для тултипов, где много текста
    ActionDateBeginCredit({commit,state,dispatch},param){
      commit('mutationDateBeginCredit',param)
    },
  },
  plugins:[
    store => {
      store.watch(
        state => [state.loanAmount, state.annualInterestRate,state.loanTerm],
        ()=>{
          store.commit('mutationTotalCalculate')
          // store.commit('mutationTotalCalculate')
        },
        {deep:true}
      )
    }
  ],
})
</script>

