// Определяю позиционирование для короткого текста
if (tooltip.classList.contains('location-side')) {
  const centerX = rect.left + rect.width / 2;
  const offset = 10; // отступ от иконки
  const minRightMargin = 50; // минимальный отступ от правого края экрана

  // === НОВАЯ ЛОГИКА ДЛЯ always-right ===
  if (trigger && trigger.classList.contains('always-right')) {
    // По умолчанию тултип справа от иконки
    // Проверяем, помещается ли тултип справа с отступом 50px от правого края
    if (rect.right + tooltipWidth + offset <= viewportWidth - minRightMargin) {
      // Помещается справа → показываем справа
      tooltip.style.left = `${rect.right + offset}px`;
      tooltip.classList.add('right');
      tooltip.classList.remove('left');
    } else {
      // Не помещается справа → показываем слева
      tooltip.style.right = `${viewportWidth - rect.left + offset}px`;
      tooltip.classList.add('left');
      tooltip.classList.remove('right');
    }
  } else {
    // Старая логика: позиционирование относительно середины экрана
    if (viewportWidth / 2 < centerX) {
      // Иконка правее середины → тултип слева от иконки
      if (rect.left - tooltipWidth - offset >= 0) {
        tooltip.style.right = `${viewportWidth - rect.left + (offset - 15)}px`;
        tooltip.classList.add('left');
        tooltip.classList.remove('right');
      } else {
        tooltip.style.left = `${rect.right + offset}px`;
        tooltip.classList.add('right');
        tooltip.classList.remove('left');
      }
    } else {
      // Иконка левее середины → тултип справа от иконки
      if (rect.right + tooltipWidth + offset <= viewportWidth) {
        tooltip.style.left = `${rect.right + offset}px`;
        tooltip.classList.add('right');
        tooltip.classList.remove('left');
      } else {
        tooltip.style.right = `${viewportWidth - rect.left + offset}px`;
        tooltip.classList.add('left');
        tooltip.classList.remove('right');
      }
    }
  }

  // === ВЕРТИКАЛЬНОЕ ПОЗИЦИОНИРОВАНИЕ ДЛЯ always-aside ===
  if (trigger && trigger.classList.contains('always-aside')) {
    const centerY = rect.top + rect.height / 2;

    if (viewportHeight / 2 < centerY) {
      // Иконка в нижней половине экрана → прижимаем НИЗ тултипа к НИЗУ иконки
      tooltip.style.top = 'auto';
      tooltip.style.bottom = `${viewportHeight - rect.bottom - 5}px`;
      tooltip.classList.add('up');
      tooltip.classList.remove('down');
    } else {
      // Иконка в верхней половине экрана → прижимаем ВЕРХ тултипа к ВЕРХУ иконки
      tooltip.style.top = `${rect.top - 5}px`;
      tooltip.style.bottom = 'auto';
      tooltip.classList.add('down');
      tooltip.classList.remove('up');
    }
  } else {
    // Обычное центрирование по вертикали
    const centerY = rect.top + rect.height / 2;
    tooltip.style.top = `${centerY - tooltipHeight / 2}px`;
    tooltip.classList.remove('up', 'down');
  }

  return;
}

-------------------------------------------------

// Определяю позиционирование для короткого текста
if (tooltip.classList.contains('location-side')) {
  const iconCenterInParent = rect.left - parentRect.left + rect.width / 2;
  const parentCenter = parentRect.width / 2;
  const offset = 10;
  const minRightMargin = 50; // минимальный отступ от правого края экрана

  // === НОВАЯ ЛОГИКА ДЛЯ always-right ===
  if (trigger && trigger.classList.contains('always-right')) {
    // По умолчанию тултип справа от иконки
    // Проверяем, помещается ли тултип справа с отступом 50px от правого края экрана
    if (rect.right + tooltipWidth + offset <= viewportWidth - minRightMargin) {
      // Помещается справа → показываем справа
      tooltip.style.left = `${rect.right + offset}px`;
      tooltip.classList.add('right');
      tooltip.classList.remove('left');
    } else {
      // Не помещается справа → показываем слева
      tooltip.style.right = `${viewportWidth - rect.left + offset}px`;
      tooltip.classList.add('left');
      tooltip.classList.remove('right');
    }
  } else {
    // Старая логика: позиционирование относительно середины родителя
    if (iconCenterInParent > parentCenter) {
      // Иконка правее середины родителя → тултип слева от иконки
      if (rect.left - tooltipWidth - offset >= parentRect.left) {
        tooltip.style.right = `${viewportWidth - rect.left + (offset - 15)}px`;
        tooltip.classList.add('left');
        tooltip.classList.remove('right');
      } else {
        tooltip.style.left = `${rect.right + offset}px`;
        tooltip.classList.add('right');
        tooltip.classList.remove('left');
      }
    } else {
      // Иконка левее середины родителя → тултип справа от иконки
      if (rect.right + tooltipWidth + offset <= parentRect.right) {
        tooltip.style.left = `${rect.right + offset}px`;
        tooltip.classList.add('right');
        tooltip.classList.remove('left');
      } else {
        tooltip.style.right = `${viewportWidth - rect.left + offset}px`;
        tooltip.classList.add('left');
        tooltip.classList.remove('right');
      }
    }
  }

  // === ВЕРТИКАЛЬНОЕ ПОЗИЦИОНИРОВАНИЕ ДЛЯ always-aside ===
  if (trigger && trigger.classList.contains('always-aside')) {
    const centerY = rect.top + rect.height / 2;

    if (viewportHeight / 2 < centerY) {
      // Иконка в нижней половине экрана → прижимаем НИЗ тултипа к НИЗУ иконки
      tooltip.style.top = 'auto';
      tooltip.style.bottom = `${viewportHeight - rect.bottom}px`;
      tooltip.classList.add('up');
      tooltip.classList.remove('down');
    } else {
      // Иконка в верхней половине экрана → прижимаем ВЕРХ тултипа к ВЕРХУ иконки
      tooltip.style.top = `${rect.top}px`;
      tooltip.style.bottom = 'auto';
      tooltip.classList.add('down');
      tooltip.classList.remove('up');
    }
  } else {
    // Обычное центрирование по вертикали
    const centerY = rect.top + rect.height / 2;
    tooltip.style.top = `${centerY - tooltipHeight / 2}px`;
    tooltip.classList.remove('up', 'down');
  }

  return;
}
