// Отправка результатов
async sendResults() {
  if (this.isSending) return;

  this.isSending = true;

  try {
    // Отправляем данные
    await this.sendingResult('result');

    // Сохраняем копию отправленных данных
    this.lastSentAnswers = JSON.parse(JSON.stringify(this.answersToSand));

    // Ждём, пока Vuex обновит answerLink
    // Мы не можем полагаться только на $nextTick — нужно ждать, пока dispatch выполнится
    // Но dispatch асинхронен, поэтому используем $nextTick + небольшое ожидание или polling

    // Дожидаемся, пока answerLink обновится
    await this.waitForAnswerLink();

    // После успешной отправки — выполнить отложенное действие
    if (this.pendingAction) {
      const { type, payload } = this.pendingAction;

      if (type === 'open') {
        const link = this.answerLink[payload];
        if (link) {
          window.open(link, '_blank');
        } else {
          console.warn(`Ссылка для ${payload} не найдена`);
        }
      } else if (type === 'copy') {
        const link = this.answerLink.link;
        if (link) {
          this.copyLinkManually(link, payload);
        } else {
          console.warn('Ссылка для копирования не найдена');
        }
      }

      this.pendingAction = null;
    }
  } catch (error) {
    console.error('Ошибка при отправке результатов:', error);
  } finally {
    this.isSending = false;
  }
},

----------------------
// Ждём, пока answerLink будет обновлён
async waitForAnswerLink(timeout = 5000) {
  const start = Date.now();
  const checkInterval = 100; // каждые 100мс проверяем

  return new Promise((resolve, reject) => {
    const interval = setInterval(() => {
      const link = this.answerLink;
      if (link && Object.keys(link).length > 0 && link.link) {
        clearInterval(interval);
        resolve();
      } else if (Date.now() - start > timeout) {
        clearInterval(interval);
        reject(new Error('Таймаут ожидания answerLink'));
      }
    }, checkInterval);
  });
}
