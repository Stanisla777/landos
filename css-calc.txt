// content-note-new.js
/* eslint-disable */

// Глобальные переменные
let activeTooltip = null;
let activeTrigger = null;
let tooltipContainer = null;
let isBodyLocked = false;
let tooltipCloseTimer = null; // Таймер для закрытия тултипа

// Создаю общий контейнер один раз
function ensureTooltipContainer() {
  if (!tooltipContainer) {
    tooltipContainer = document.createElement('div');
    tooltipContainer.className = 'tooltip-popup-container';
    Object.assign(tooltipContainer.style, {
      position: 'fixed',
      top: '0',
      left: '0',
      width: '100%',
      height: '100%',
      pointerEvents: 'none',
      zIndex: '2147483646',
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
    });
    document.body.appendChild(tooltipContainer);
  }

  return tooltipContainer;
}

// Функции блокировки/разблокировки скролла
function addClassBody() {
  if (isBodyLocked) return;
  isBodyLocked = true;
  document.body.classList.add('body-modal', 'body-additional-class');
}

function removeClassBody() {
  if (!document.body.classList.contains('body-modal-modals')) {
    document.body.classList.remove('body-modal', 'body-additional-class');
  }
  isBodyLocked = false;
}

// Определяю мобильное или планшетное устройства
function isMobileDevice() {
  return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
}

function isMobilePhone() {
  const ua = navigator.userAgent;
  if (/iPhone/.test(ua) && !/iPad/.test(ua)) return true;
  if (/Android/.test(ua) && /Mobile/.test(ua)) return true;
  return false;
}

// Созданю тултип
function createTooltip(content, trigger) {
  const tooltip = document.createElement('div');
  tooltip.className = 'content-note__text-new';
  // УБРАЛИ инлайн-стили для opacity и transition

  // Добавляем классы из триггера, начинающиеся с 'class-for-tooltip-'
  if (trigger) {
    const triggerClasses = Array.from(trigger.classList);
    const tooltipClasses = triggerClasses.filter(className =>
      className.startsWith('class-for-tooltip-')
    );
    if (tooltipClasses.length > 0) {
      tooltip.classList.add(...tooltipClasses);
    }
  }

  // Проверяю, содержит ли контент HTML
  const hasHTML = /<[^>]+>/.test(content);
  const textLength = content.replace(/<[^>]+>/g, '').length;

  // Определяю тип позиционирования
  if (trigger && trigger.classList.contains('aside-location') && !hasHTML && textLength <= 40) {
    tooltip.classList.add('location-side');
  }

  // Добавляю контент
  tooltip.innerHTML = content;

  return tooltip;
}

// Общая функция для вертикального позиционирования тултипа
function positionTooltipVertically(rect, tooltip, offset = 4) {
  const viewportHeight = window.innerHeight;
  const topOffset = rect.top + rect.height / 2;

  if (viewportHeight / 2 < topOffset) {
    // Иконка ниже середины экрана → тултип сверху
    tooltip.style.top = 'auto';
    tooltip.style.bottom = `${viewportHeight - rect.top + (offset + 6)}px`;
    tooltip.classList.add('up');
    tooltip.classList.remove('down');
  } else {
    // Иконка выше середины экрана → тултип снизу
    tooltip.style.top = `${rect.bottom - (offset - 13)}px`;
    tooltip.style.bottom = 'auto';
    tooltip.classList.add('down');
    tooltip.classList.remove('up');
  }
}

// Позиционирование тултипа относительно экрана
function positionTooltip(trigger, tooltip) {
  const rect = trigger.getBoundingClientRect();
  const viewportWidth = window.innerWidth;
  const viewportHeight = window.innerHeight;

  const isNarrow = window.matchMedia('(max-width: 480px)').matches;

  // Для мобильных телефонов использую мобильный вид
  if (isMobilePhone() || isNarrow) {
    tooltip.classList.add('mobile-tooltip');
    return;
  }

  // Сбрасываю позиционирование
  tooltip.style.left = '';
  tooltip.style.right = '';
  tooltip.style.top = '';
  tooltip.style.bottom = '';
  tooltip.style.transform = '';

  // Измеряю размеры тултипа
  const originalDisplay = tooltip.style.display;
  tooltip.style.display = 'block';
  tooltip.style.opacity = '0';
  const tooltipRect = tooltip.getBoundingClientRect();
  const tooltipWidth = tooltipRect.width;
  const tooltipHeight = tooltipRect.height;
  tooltip.style.display = originalDisplay;
  tooltip.style.opacity = '';

  // Определяю позиционирование для короткого текста
  if (tooltip.classList.contains('location-side')) {
    const centerX = rect.left + rect.width / 2;
    const centerY = rect.top + rect.height / 2;
    const offset = 10; // отступ от иконки

    // Основное позиционирование - зависит от положения иконки относительно середины экрана
    if (viewportWidth / 2 < centerX) {
      // Иконка правее середины → тултип слева от иконки
      // Проверяем, что тултип не вылезает за левый край
      if (rect.left - tooltipWidth - offset >= 0) {
        // Помещается слева → показываем слева
        tooltip.style.right = `${viewportWidth - rect.left + (offset - 15)}px`;
        tooltip.classList.add('left');
        tooltip.classList.remove('right');
      } else {
        // Не помещается слева → показываем справа
        tooltip.style.left = `${rect.right + offset}px`;
        tooltip.classList.add('right');
        tooltip.classList.remove('left');
      }
    } else {
      // Иконка левее середины → тултип справа от иконки
      // Проверяем, что тултип не вылезает за правый край
      if (rect.right + tooltipWidth + offset <= viewportWidth) {
        // Помещается справа → показываем справа
        tooltip.style.left = `${rect.right + offset}px`;
        tooltip.classList.add('right');
        tooltip.classList.remove('left');
      } else {
        // Не помещается справа → показываем слева
        tooltip.style.right = `${viewportWidth - rect.left + offset}px`;
        tooltip.classList.add('left');
        tooltip.classList.remove('right');
      }
    }

    // Вертикальное позиционирование (по центру иконки)
    tooltip.style.top = `${centerY - tooltipHeight / 2}px`;
    tooltip.classList.remove('up', 'down');

    return;
  }

  // Для длинного текста использую стандартное позиционирование

  // Горизонтальное позиционирование
  // Если центр иконки правее середины экрана → тултип слева от иконки
  // Если центр иконки левее середины экрана → тултип справа от иконки
  const leftOffset = rect.left + rect.width / 2;
  const offset = 4; // отступ от иконки

  if (viewportWidth / 2 < leftOffset) {
    // Иконка правее середины → тултип слева от иконки - прижимаем к ПРАВОМУ краю иконки
    tooltip.style.left = 'auto';
    tooltip.style.right = `${viewportWidth - rect.right + (offset - 21)}px`;
    tooltip.classList.add('left');
    tooltip.classList.remove('right');
  } else {
    // Иконка левее середины → тултип справа от иконки - прижимаем к ЛЕВОМУ краю иконки
    tooltip.style.left = `${rect.left - offset}px`;
    tooltip.style.right = 'auto';
    tooltip.classList.add('right');
    tooltip.classList.remove('left');
  }

  // Вертикальное позиционирование - используем общую функцию
  positionTooltipVertically(rect, tooltip, offset);
}

// Позиционирование тултипа относительно родителя с классом .js--focus-on-parent
function positionTooltipRelativeToParent(trigger, tooltip) {
  const rect = trigger.getBoundingClientRect();
  const viewportWidth = window.innerWidth;
  const viewportHeight = window.innerHeight;

  const isNarrow = window.matchMedia('(max-width: 480px)').matches;

  // Для мобильных телефонов использую мобильный вид
  if (isMobilePhone() || isNarrow) {
    tooltip.classList.add('mobile-tooltip');
    return;
  }

  // Сбрасываю позиционирование
  tooltip.style.left = '';
  tooltip.style.right = '';
  tooltip.style.top = '';
  tooltip.style.bottom = '';
  tooltip.style.transform = '';

  // Измеряю размеры тултипа
  const originalDisplay = tooltip.style.display;
  tooltip.style.display = 'block';
  tooltip.style.opacity = '0';
  const tooltipRect = tooltip.getBoundingClientRect();
  const tooltipWidth = tooltipRect.width;
  const tooltipHeight = tooltipRect.height;
  tooltip.style.display = originalDisplay;
  tooltip.style.opacity = '';

  // Находим родителя с классом .js--focus-on-parent
  const focusParent = trigger.closest('.js--focus-on-parent');
  if (!focusParent) {
    // Если родителя нет, используем обычное позиционирование
    positionTooltip(trigger, tooltip);
    return;
  }

  const parentRect = focusParent.getBoundingClientRect();

  // Определяю позиционирование для короткого текста
  if (tooltip.classList.contains('location-side')) {
    const iconCenterInParent = rect.left - parentRect.left + rect.width / 2;
    const parentCenter = parentRect.width / 2;
    const centerY = rect.top + rect.height / 2;
    const offset = 10;

    // Горизонтальное позиционирование
    if (iconCenterInParent > parentCenter) {
      // Иконка правее середины родителя → тултип слева от иконки
      // Проверяем, что тултип не выходит за левую границу родителя
      if (rect.left - tooltipWidth - offset >= parentRect.left) {
        tooltip.style.right = `${viewportWidth - rect.left + (offset - 15)}px`;
        tooltip.classList.add('left');
        tooltip.classList.remove('right');
      } else {
        // Не помещается слева → показываем справа
        tooltip.style.left = `${rect.right + offset}px`;
        tooltip.classList.add('right');
        tooltip.classList.remove('left');
      }
    } else {
      // Иконка левее середины родителя → тултип справа от иконки
      // Проверяем, что тултип не выходит за правую границу родителя
      if (rect.right + tooltipWidth + offset <= parentRect.right) {
        tooltip.style.left = `${rect.right + offset}px`;
        tooltip.classList.add('right');
        tooltip.classList.remove('left');
      } else {
        // Не помещается справа → показываем слева
        tooltip.style.right = `${viewportWidth - rect.left + offset}px`;
        tooltip.classList.add('left');
        tooltip.classList.remove('right');
      }
    }

    // Вертикальное позиционирование (по центру иконки)
    tooltip.style.top = `${centerY - tooltipHeight / 2}px`;
    tooltip.classList.remove('up', 'down');

    return;
  }

  // Для длинного текста используем стандартное позиционирование

  // Горизонтальное позиционирование (относительно родителя)
  const iconCenterInParent = rect.left - parentRect.left + rect.width / 2;
  const parentCenter = parentRect.width / 2;
  const offset = 4;

  if (iconCenterInParent > parentCenter) {
    // Иконка правее середины родителя → тултип слева от иконки
    // Проверяем, что тултип не выходит за левую границу родителя
    if (rect.left - tooltipWidth - offset >= parentRect.left) {
      tooltip.style.left = 'auto';
      tooltip.style.right = `${viewportWidth - rect.right + (offset - 20)}px`;
      tooltip.classList.add('left');
      tooltip.classList.remove('right');
    } else {
      // Не помещается слева → показываем справа
      tooltip.style.left = `${rect.left - offset}px`;
      tooltip.style.right = 'auto';
      tooltip.classList.add('right');
      tooltip.classList.remove('left');
    }
  } else {
    // Иконка левее середины родителя → тултип справа от иконки
    // Проверяем, что тултип не выходит за правую границу родителя
    if (rect.right + tooltipWidth + offset <= parentRect.right) {
      tooltip.style.left = `${rect.left - offset}px`;
      tooltip.style.right = 'auto';
      tooltip.classList.add('right');
      tooltip.classList.remove('left');
    } else {
      // Не помещается справа → показываем слева
      tooltip.style.left = 'auto';
      tooltip.style.right = `${viewportWidth - rect.right + offset}px`;
      tooltip.classList.add('left');
      tooltip.classList.remove('right');
    }
  }

  // Вертикальное позиционирование - используем общую функцию
  positionTooltipVertically(rect, tooltip, offset);
}

// Показ тултипа
function showTooltip(trigger, content) {
  if (activeTooltip) {
    hideTooltip(activeTooltip);
  }

  const tooltip = createTooltip(content, trigger);
  const container = ensureTooltipContainer();
  container.appendChild(tooltip);

  // Определяю, какую функцию позиционирования использовать
  const focusParent = trigger.closest('.js--focus-on-parent');
  if (focusParent) {
    positionTooltipRelativeToParent(trigger, tooltip);
  } else {
    positionTooltip(trigger, tooltip);
  }

  // === КРИТИЧЕСКИ ВАЖНО: правильная последовательность анимации ===
  // Сначала сбрасываем все активные состояния
  container.classList.remove('active');
  tooltip.classList.remove('active');

  // Принудительный reflow для применения изменений
  void tooltip.offsetWidth;

  requestAnimationFrame(() => {
    requestAnimationFrame(() => {
      const isNarrow = window.matchMedia('(max-width: 480px)').matches;
      const isMobile = isMobilePhone() || isNarrow;

      // Устанавливаем transition ТОЛЬКО в момент анимации
      if (isMobile) {
        tooltip.style.transition = 'transform 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
      } else {
        tooltip.style.transition = 'opacity 0.2s ease';
        tooltip.style.opacity = '0'; // Начальное состояние для десктопа
      }

      // Добавляем активные классы
      container.classList.add('active');
      tooltip.classList.add('active');

      // Для десктопа устанавливаем конечное состояние opacity
      if (!isMobile) {
        tooltip.style.opacity = '1';
      }

      // Для мобильных добавляем класс контейнера
      if (isMobile) {
        container.classList.add('mobile-tooltip');
      }
    });
  });

  activeTooltip = tooltip;
  activeTrigger = trigger;

  if (isMobileDevice()) {
    addClassBody();
  }
}

// Скрытие тултипа
function hideTooltip(tooltip) {
  if (!tooltip) return;

  if (tooltipCloseTimer) {
    clearTimeout(tooltipCloseTimer);
    tooltipCloseTimer = null;
  }

  const isNarrow = window.matchMedia('(max-width: 480px)').matches;
  const isMobile = isMobilePhone() || isNarrow;

  // === Устанавливаем переход ТОЛЬКО для мобильных ===
  if (isMobile) {
    tooltip.style.transition = 'transform 0.25s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
  } else {
    // Для десктопа убираем переход и удаляем мгновенно
    tooltip.style.transition = 'none';
  }

  tooltip.style.pointerEvents = 'none';

  // === Устанавливаем прозрачность ТОЛЬКО для десктопа ===
  if (!isMobile) {
    tooltip.style.opacity = '0';
  }

  // Удаляем активный класс
  tooltip.classList.remove('active');

  // === Таймаут: 300мс для мобильных, 0мс для десктопа ===
  setTimeout(() => {
    if (tooltip.parentNode) {
      tooltip.parentNode.removeChild(tooltip);

      if (!tooltipContainer.querySelector('.content-note__text-new')) {
        tooltipContainer.classList.remove('active');
        tooltipContainer.classList.remove('mobile-tooltip');
      }
    }

    if (isMobileDevice()) {
      removeClassBody();
    }
  }, isMobile ? 300 : 0);

  activeTooltip = null;
  activeTrigger = null;
}

// ОБРАБОТЧИК НАВЕДЕНИЯ
function handleMouseOver(e) {
  // Проверяю, что e.target существует и имеет метод closest
  if (!e.target || typeof e.target.closest !== 'function') return;

  // ищем .js--content-note-new, включая самого элемента и его потомков
  const trigger = e.target.closest('.js--content-note-new');
  if (!trigger) return;

  // Проверяю, есть ли класс not-use-tooltip у триггера или его потомков
  const hasNotUseTooltip = trigger.classList.contains('not-use-tooltip') ||
    trigger.querySelector('.not-use-tooltip');
  if (hasNotUseTooltip) {
    return;
  }

  // Проверяю, есть ли класс для отключения на мобильных
  if (isMobileDevice() && trigger.classList.contains('not-use-tooltip-mobile')) {
    return;
  }

  // Читаю контент именно из этого элемента
  const content = trigger.dataset.contentText || '';

  // Дополнительная проверка на пустой контент
  if (!content || content.trim() === '') {
    console.warn('Тултип не показан: отсутствует или пустой атрибут data-content-text', trigger);
    return;
  }

  // Если уже открыт тултип для этого же блока - ничего не делаю
  if (activeTooltip && activeTrigger === trigger) {
    return;
  }

  // Отменяю предыдущий таймер закрытия
  if (tooltipCloseTimer) {
    clearTimeout(tooltipCloseTimer);
    tooltipCloseTimer = null;
  }

  // Показываю тултип с контентом из именно блока по который навели
  showTooltip(trigger, content);
}

// ОБРАБОТЧИК УХОДА МЫШИ (использую mouseout - работает надёжнее для этой задачи)
function handleMouseOut(e) {
  // Проверяю, что e.target существует и имеет метод closest
  if (!e.target || typeof e.target.closest !== 'function') return;

  // === НАХОЖУ ТРИГГЕР: ищем .js--content-note-new, включая самого элемента и его потомков ===
  const trigger = e.target.closest('.js--content-note-new');

  // === КРИТИЧЕСКИ ВАЖНО: проверяем, что уходим именно с триггера или его потомков ===
  const relatedTarget = e.relatedTarget || e.toElement;

  // Если уходим на потомка триггера - ничего не делаем
  if (trigger && relatedTarget && trigger.contains(relatedTarget)) {
    return;
  }

  // Если уходим на потомка тултипа - ничего не делаем
  if (activeTooltip && relatedTarget && activeTooltip.contains(relatedTarget)) {
    return;
  }

  // Проверяю, что relatedTarget существует и имеет метод closest
  const isTooltip = relatedTarget &&
    typeof relatedTarget.closest === 'function' &&
    relatedTarget.closest('.content-note__text-new');

  // Если уходим не с нашего триггера или уходим на сам тултип - ничего не делаем
  if (!trigger || isTooltip) {
    return;
  }

  // Отменяю предыдущий таймер
  if (tooltipCloseTimer) {
    clearTimeout(tooltipCloseTimer);
  }

  // Задержка перед скрытием для плавности
  tooltipCloseTimer = setTimeout(() => {
    if (activeTooltip && activeTrigger === trigger) {
      hideTooltip(activeTooltip);
    }
    tooltipCloseTimer = null;
  }, 150);
}

// ОБРАБОТЧИК УХОДА МЫШИ С ТУЛТИПА
function handleTooltipMouseOut(e) {
  // Проверяю, что уходим именно с тултипа
  if (!e.target || typeof e.target.closest !== 'function') return;

  const tooltip = e.target.closest('.content-note__text-new');
  if (!tooltip || tooltip !== activeTooltip) {
    return;
  }

  const relatedTarget = e.relatedTarget || e.toElement;

  // === КРИТИЧЕСКИ ВАЖНО: проверяем, уходим ли мы на потомка тултипа ===
  if (relatedTarget && tooltip.contains(relatedTarget)) {
    // Уходим на вложенный элемент внутри тултипа - не закрываем
    return;
  }

  // Проверяю, куда уходим - если на иконку-триггер, то не закрываем
  const isTrigger = relatedTarget &&
    typeof relatedTarget.closest === 'function' &&
    relatedTarget.closest('.js--content-note-new');

  // Если уходим на триггер - ничего не делаем
  if (isTrigger) {
    return;
  }

  // Отменяю предыдущий таймер
  if (tooltipCloseTimer) {
    clearTimeout(tooltipCloseTimer);
  }

  // Закрываем тултип, так как уходим не на триггер и не на потомка
  tooltipCloseTimer = setTimeout(() => {
    if (activeTooltip) {
      hideTooltip(activeTooltip);
    }
    tooltipCloseTimer = null;
  }, 150);
}


// ОБРАБОТЧИК КЛИКА ДЛЯ МОБИЛЬНЫХ
function handleClick(e) {
  // Проверяю, что e.target существует и имеет метод closest
  if (!e.target || typeof e.target.closest !== 'function') return;

  const trigger = e.target.closest('.js--content-note-new');
  if (!trigger) return;

  // Проверяю, есть ли класс not-use-tooltip у триггера или его потомков
  const hasNotUseTooltip = trigger.classList.contains('not-use-tooltip') ||
    trigger.querySelector('.not-use-tooltip');
  if (hasNotUseTooltip) {
    return;
  }

  // Проверяю, есть ли класс для отключения на всех тач-устройствах (телефоны + планшеты)
  if (isMobileDevice() && trigger.classList.contains('not-use-tooltip-mobile')) {
    return;
  }

  // Читаю контент именно из этого элемента
  const content = trigger.dataset.contentText || '';

  // Дополнительная проверка на пустой контент
  if (!content || content.trim() === '') {
    console.warn('Тултип не показан: отсутствует или пустой атрибут data-content-text', trigger);
    return;
  }

  // Предотвращаю стандартное поведение
  e.preventDefault();

  // Если тултип уже открыт для этого же триггера - закрываем
  if (activeTooltip && activeTrigger === trigger) {
    hideTooltip(activeTooltip);
    return;
  }

  // Показываю тултип с контентом из блока по которому кликнули
  showTooltip(trigger, content);
}

// Обработчик клика вне тултипа
function handleClickOutside(e) {
  if (!activeTooltip) return;

  const clickedInside = activeTooltip.contains(e.target) ||
    (activeTrigger && activeTrigger.contains(e.target));

  if (!clickedInside) {
    hideTooltip(activeTooltip);
  }
}

// Обработчик изменения размера окна
function handleResize() {
  if (activeTooltip && activeTrigger) {
    const focusParent = activeTrigger.closest('.js--focus-on-parent');
    if (focusParent) {
      positionTooltipRelativeToParent(activeTrigger, activeTooltip);
    } else {
      positionTooltip(activeTrigger, activeTooltip);
    }
  }

  // Для мобильных устройств закрываю тултип при изменении ориентации
  const isNarrow = window.matchMedia('(max-width: 480px)').matches;

  if (isMobilePhone() && !isNarrow && activeTooltip) {
    hideTooltip(activeTooltip);
  }
}

// Инициализация
export default function contentNoteNew() {
  //  Закрываю тултип при скролле
  const handleScroll = () => {
    if (activeTooltip) {
      hideTooltip(activeTooltip);
    }
  };

  // Добавляю обработчики событий
  document.addEventListener('mouseover', handleMouseOver);
  // Использую mouseout вместо mouseleave - работает надёжнее для этой задачи
  document.addEventListener('mouseout', handleMouseOut);
  // Добавляю обработчик ухода с тултипа
  document.addEventListener('mouseout', handleTooltipMouseOut);
  document.addEventListener('click', handleClickOutside);
  window.addEventListener('resize', handleResize);

  // === НОВЫЙ: Закрываем тултип мгновенно при клике на иконку с модалкой (только десктоп) ===
  document.addEventListener('click', (e) => {
    // Проверяем, что это не мобильное устройство
    if (isMobileDevice()) return;

    // Проверяем, что кликнули на иконку тултипа
    const trigger = e.target.closest('.js--content-note-new');
    if (!trigger) return;

    // Проверяем, есть ли класс .js--modal-opener у иконки или её родителя
    const hasModalOpener = trigger.classList.contains('js--modal-opener') ||
      trigger.closest('.js--modal-opener');

    if (hasModalOpener && activeTooltip) {
      // Мгновенно закрываем тултип без задержки
      hideTooltip(activeTooltip);
    }
  });

  // Скролл страницы
  window.addEventListener('scroll', handleScroll, { passive: true });
  // Прокрутка колёсиком мыши
  document.addEventListener('wheel', handleScroll, { passive: true });

  // Для мобильных устройств использую клик вместо наведения
  const isIOS = (/(iPad|iPhone|iPod)/.test(navigator.userAgent) && !window.MSStream) ||
    (navigator.userAgent.includes('Mac') && 'ontouchend' in document);

  if (isIOS || isMobileDevice()) {
    document.addEventListener('touchstart', handleClick, { passive: false });
    // Свайп на мобильных
    document.addEventListener('touchmove', handleScroll, { passive: true });
  }

  // Обработчик для закрытия по клику на крестики в мобильном тултипе
  document.addEventListener('click', (e) => {
    // Закрытие по крестику (псевдоэлемент ::after)
    if (activeTooltip && activeTooltip.classList.contains('mobile-tooltip')) {
      const rect = activeTooltip.getBoundingClientRect();
      const closeButtonRect = {
        top: rect.top + 12,
        right: rect.right - 16,
        width: 32,
        height: 32
      };

      if (
        e.clientX >= closeButtonRect.right - closeButtonRect.width &&
        e.clientX <= closeButtonRect.right &&
        e.clientY >= closeButtonRect.top &&
        e.clientY <= closeButtonRect.top + closeButtonRect.height
      ) {
        hideTooltip(activeTooltip);
        return;
      }
    }

    // Закрытие по клику на затемнённый фон контейнера
    if (e.target === tooltipContainer && tooltipContainer.classList.contains('mobile-tooltip')) {
      hideTooltip(activeTooltip);
    }
  });
}


Стили такие сейчас:
.tooltip-popup-container {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  z-index: 1110;
  display: flex;
  align-items: center;
  justify-content: center;
  &.active{
    &.mobile-tooltip {
      background-color: rgba(0, 0, 0, .5);
    }
  }


}

.content-note__text-new {
  position: absolute;
  background-color: $color-text-new;
  border-radius: 4px;
  padding: 16px;
  box-shadow: none;
  max-width: 256px;
  opacity: 0;
  pointer-events: none;
  // УБРАЛИ transition из общих стилей!
  font-family: $ff-semi-bold;
  font-size: 12px;
  line-height: 16px;
  color: #fff;
  p,a,li,b,i{
    font-family: inherit;
    font-size: inherit;
    line-height: inherit;
    color: inherit;
  }
  a {
    @include underline-link(3px);
  }
  &.active {
    opacity: 1;
    pointer-events: auto;
  }
  // Позиционирование для короткого текста
  &.location-side {
    //max-width: 280px;
  }
  // Стрелка для тултипа
  &::before {
    content: '';
    position: absolute;
    width: 0;
    height: 0;
    border-style: solid;
    border-color: transparent;
    border-width: 6px;
    z-index: 1;
  }
  &.left::before {
    right: -12px;
    top: 50%;
    transform: translateY(-50%);
    border-left-color: $color-text-new;
  }
  &.right::before {
    left: -12px;
    top: 50%;
    transform: translateY(-50%);
    border-right-color: $color-text-new;
  }
  &.right.up {
    &::before {
      left: 5px;
      top: 100%;
      border-color: black transparent transparent transparent;
      transform: translateY(0);
    }
  }
  &.right.down {
    &::before {
      bottom: 100%;
      border-color: transparent transparent #000;
      left: 5px;
      transform: translateY(0);
      top: unset;
    }
  }
  &.left.up {
    &::before {
      top: 100%;
      border-color: #000 transparent transparent;
      right: 7px;
      transform: translateY(0);
    }
  }
  &.left.down {
    &::before {
      bottom: 100%;
      border-color: transparent transparent #000;
      right: 7px;
      top: unset;
      transform: translateY(0);
    }
  }
  //свойства для тултипа с определённым классом
  &.class-for-tooltip-hert{
    &.right.down {
      &::before {
        left: 9px;
      }
    }
    &.right.up {
      &::before {
        left: 9px;
      }
    }
  }
  // Мобильный вид
  &.mobile-tooltip {
    color: $color-text-new;
    position: fixed;
    padding-top: 20px;
    bottom: 0;
    top: unset !important;
    left: 50%;
    transform: translate(-50%, 101%) !important; // Начальное состояние (за экраном)
    height: max-content;
    width: 101%;
    max-width: unset;
    border-top-left-radius: 16px;
    border-top-right-radius: 16px;
    border-bottom-left-radius: 0;
    border-bottom-right-radius: 0;
    max-height: 80vh;
    overflow-y: auto;
    background-color: #fff;
    opacity: 1 !important; // Всегда видим для анимации transform

    &.active {
      transform: translate(-50%, 0) !important; // Конечное состояние (в экране)
    }

    // Мобильный хедер
    &::before {
      display: none;
    }

    // Кнопка закрытия
    &::after {
      content: '×';
      position: absolute;
      top: 12px;
      right: 16px;
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      font-weight: bold;
      color: #666;
      cursor: pointer;
      z-index: 11;
      transition: color 0.2s ease;

      &:hover {
        color: #333;
      }
    }
  }
}
