scrollToElementSmart(container, targetElement) {
  const containerRect = container.getBoundingClientRect();
  const targetRect = targetElement.getBoundingClientRect();
  const pageScrollTop = window.scrollY;

  const targetTopInContainer = targetRect.top - containerRect.top + container.scrollTop;
  const maxContainerScroll = container.scrollHeight - container.clientHeight;

  // Желаемая позиция скролла контейнера, чтобы элемент был вверху
  const desiredContainerScroll = Math.max(0, Math.min(targetTopInContainer, maxContainerScroll));

  // Проверка: может ли контейнер проскроллиться?
  const canScrollContainer = container.scrollHeight > container.clientHeight;

  if (canScrollContainer) {
    // Скроллим контейнер, чтобы элемент оказался вверху контейнера
    this.smoothScrollTo(container, 'scrollTop', desiredContainerScroll, 300, (val) => {
      container.scrollTop = val;
    });

    // После анимации проверяем, попал ли элемент в нужную позицию на экране
    setTimeout(() => {
      const finalTargetRect = targetElement.getBoundingClientRect();

      // Если элемент выходит за пределы экрана — подкручиваем страницу
      if (finalTargetRect.top < 0 || finalTargetRect.bottom > window.innerHeight) {
        const newPageScrollTop = window.scrollY + finalTargetRect.top - 10;
        this.smoothScrollTo(window, 'scrollY', newPageScrollTop, 300, (val) => {
          window.scrollTo(0, val);
        });
      }
    }, 310);
  } else {
    // Контейнер не скроллится — скроллим страницу к самому элементу (вверх экрана)
    const targetPageScrollTop = pageScrollTop + targetRect.top - 10; // 10 — небольшой отступ сверху
    this.smoothScrollTo(window, 'scrollY', targetPageScrollTop, 300, (val) => {
      window.scrollTo(0, val);
    });
  }
},
