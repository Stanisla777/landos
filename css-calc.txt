// Обработчик клика на ссылку
async handleLinkClick(type) {
  // Проверяем, есть ли уже ссылка
  if (!this.answerLink[type]) {
    // Если ссылки нет, отправляем данные
    this.pendingLink = type; // Сохраняем тип ссылки вместо самой ссылки
    await this.sendResults();
    return;
  }

  const link = this.answerLink[type];

  // Проверяем, изменились ли данные с последней отправки
  if (this.hasAnswersChanged()) {
    this.pendingLink = type; // Сохраняем тип ссылки вместо самой ссылки
    await this.sendResults();
  } else {
    // Если данные не изменились, просто открываем ссылку
    if (link) {
      window.open(link, '_blank');
    }
  }
},

// Обработчик клика на копирование
async handleCopyClick(event) {
  const link = event.currentTarget.dataset.link;

  // Если ссылки нет или данные изменились, отправляем данные
  if (!link || this.hasAnswersChanged()) {
    this.pendingLink = 'copy'; // Помечаем, что нужно выполнить копирование
    await this.sendResults();
  } else {
    // Если ссылка есть и данные не изменились, копируем сразу
    this.copyLink(event);
  }
},

// Отправка результатов
async sendResults() {
  if (this.isSending) return;

  this.isSending = true;

  try {
    await this.sendingResult('result');
    this.lastSentAnswers = JSON.parse(JSON.stringify(this.answersToSand));

    // Если есть ссылка, которую нужно открыть после отправки
    if (this.pendingLink) {
      if (this.pendingLink === 'copy') {
        // Найти элемент для копирования и вызвать copyLink
        const element = document.querySelector('[data-link]');
        if (element) {
          this.copyLink({ currentTarget: element });
        }
      } else if (this.answerLink[this.pendingLink]) {
        window.open(this.answerLink[this.pendingLink], '_blank');
      }
      this.pendingLink = null;
    }
  } catch (error) {
    console.error('Ошибка при отправке результатов:', error);
  } finally {
    this.isSending = false;
  }
},
