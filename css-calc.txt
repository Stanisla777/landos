/* eslint-disable */
import Vue from 'vue';
import axios from 'axios';

export default function marathon2025Shedule() {
  const app = new Vue({
    el: '#marathon-2025-shedule',
    data: {
      currentMonth: null,
      currentYear: null,
      selectedDate: null,
      events: [],
      minDate: null,
      maxDate: null,
      screenWidth: window.innerWidth,
      screenHeight: window.innerHeight,
      contentObserver: null,
    },
    computed: {
      weekdays() {
        return ['Пн', 'Вт', 'Ср', 'Чт', 'Пт', 'Сб', 'Вс'];
      },
      currentMonthName() {
        const months = [
          'Январь', 'Февраль', 'Март', 'Апрель', 'Май', 'Июнь',
          'Июль', 'Август', 'Сентябрь', 'Октябрь', 'Ноябрь', 'Декабрь'
        ];
        return months[this.currentMonth];
      },

      getDaysInGrid() {
        const days = [];
        const firstDay = new Date(this.currentYear, this.currentMonth, 1).getDay();
        const daysInMonth = new Date(this.currentYear, this.currentMonth + 1, 0).getDate();

        const prevMonth = this.currentMonth === 0 ? 11 : this.currentMonth - 1;
        const prevYear = this.currentMonth === 0 ? this.currentYear - 1 : this.currentYear;
        const daysInPrevMonth = new Date(prevYear, prevMonth + 1, 0).getDate();

        const prevDaysCount = firstDay === 0 ? 6 : firstDay - 1;

        for (let i = 0; i < prevDaysCount; i++) {
          const dayNumber = daysInPrevMonth - (prevDaysCount - 1 - i);
          const date = new Date(prevYear, prevMonth, dayNumber);
          const dateStr = this.formatDateForData(date);
          const normalizedDate = this.normalizeDate(dateStr);
          const eventItem = this.events.find(e => this.normalizeDate(e.date) === normalizedDate);

          days.push({
            number: dayNumber,
            date: dateStr,
            isPrevMonth: true,
            isNextMonth: false,
            hasEvents: !!eventItem,
            events: eventItem ? eventItem.events : [],
            month: prevMonth,
            year: prevYear
          });
        }

        for (let day = 1; day <= daysInMonth; day++) {
          const date = new Date(this.currentYear, this.currentMonth, day);
          const dateStr = this.formatDateForData(date);
          const normalizedDate = this.normalizeDate(dateStr);
          const eventItem = this.events.find(e => this.normalizeDate(e.date) === normalizedDate);

          days.push({
            number: day,
            date: dateStr,
            isPrevMonth: false,
            isNextMonth: false,
            hasEvents: !!eventItem,
            events: eventItem ? eventItem.events : [],
            month: this.currentMonth,
            year: this.currentYear
          });
        }

        const nextMonth = this.currentMonth === 11 ? 0 : this.currentMonth + 1;
        const nextYear = this.currentMonth === 11 ? this.currentYear + 1 : this.currentYear;

        while (days.length < 42) {
          const dayNumber = days.length - daysInMonth - prevDaysCount + 1;
          const date = new Date(nextYear, nextMonth, dayNumber);
          const dateStr = this.formatDateForData(date);
          const normalizedDate = this.normalizeDate(dateStr);
          const eventItem = this.events.find(e => this.normalizeDate(e.date) === normalizedDate);

          days.push({
            number: dayNumber,
            date: dateStr,
            isPrevMonth: false,
            isNextMonth: true,
            hasEvents: !!eventItem,
            events: eventItem ? eventItem.events : [],
            month: nextMonth,
            year: nextYear
          });
        }

        const weeks = [];
        for (let i = 0; i < days.length; i += 7) {
          weeks.push(days.slice(i, i + 7));
        }

        const filteredWeeks = weeks.filter(week => {
          return week.some(day => day.month === this.currentMonth && day.year === this.currentYear);
        });

        return filteredWeeks.flat();
      },

      eventsForSelectedDay() {
        if (!this.selectedDate) return [];
        const normalized = this.normalizeDate(this.selectedDate);
        const dayData = this.events.find(e => this.normalizeDate(e.date) === normalized);
        if (!dayData) return [];

        return [...dayData.events].sort((a, b) => {
          const order = [3, 1, 2];
          return order.indexOf(a.type) - order.indexOf(b.type);
        });
      },

      canGoPrev() {
        if (!this.minDate) return false;
        const current = this.currentYear * 12 + this.currentMonth;
        const min = this.minDate.year * 12 + this.minDate.month;
        return current > min;
      },

      canGoNext() {
        if (!this.maxDate) return false;
        const current = this.currentYear * 12 + this.currentMonth;
        const max = this.maxDate.year * 12 + this.maxDate.month;
        return current < max;
      },
    },

    methods: {
      updateScreenWidth() {
        const oldWidth = this.screenWidth;
        this.screenWidth = window.innerWidth;
        this.screenHeight = window.innerHeight;

        // Всегда синхронизируем при изменении ширины на десктопе
        if (this.screenWidth >= 990) {
          // Небольшая задержка чтобы дать браузеру перерисовать контент
          setTimeout(() => {
            this.syncCalendarHeight();
          }, 50);
        } else if (oldWidth >= 990 && this.screenWidth < 990) {
          // При переходе на мобильный - сбрасываем высоты
          this.resetCalendarHeights();
        }
      },

      syncCalendarHeight() {
        if (this.screenWidth < 990) {
          this.resetCalendarHeights();
          return;
        }
        
        this.$nextTick(() => {
          const calendarColumn = this.$el.querySelector('.marathon-2025__calendar-column');
          const eventsColumn = this.$el.querySelector('.marathon-2025__events-column');
          
          if (!calendarColumn || !eventsColumn) return;
          
          // Сначала сбрасываем высоты чтобы получить естественную высоту контента
          this.resetCalendarHeights();
          
          // Даем браузеру время на перерисовку
          setTimeout(() => {
            const eventsHeight = eventsColumn.offsetHeight;
            const baseCalendarHeight = this.calculateBaseCalendarHeight();
            
            console.log('Events height:', eventsHeight, 'Base calendar height:', baseCalendarHeight);
            
            // Если контент в правой колонке ВМЕЩАЕТСЯ в базовую высоту - не растягиваем
            if (eventsHeight <= baseCalendarHeight) {
              this.resetCalendarHeights();
              return;
            }
            
            // Если контент НЕ ВМЕЩАЕТСЯ - растягиваем
            calendarColumn.style.minHeight = eventsHeight + 'px';
            this.calculateCellHeights(eventsHeight);
          }, 10);
        });
      },

      calculateBaseCalendarHeight() {
        const calendarHeader = this.$el.querySelector('.marathon-2025__calendar-header');
        const dayHeaders = this.$el.querySelector('.marathon-2025__calendar-grid:first-child');
        
        const headerHeight = calendarHeader ? calendarHeader.offsetHeight : 0;
        const dayHeaderHeight = dayHeaders ? dayHeaders.offsetHeight : 0;
        
        const rowCount = Math.ceil(this.getDaysInGrid.length / 7);
        
        let cellHeight;
        if (this.screenWidth < 590) {
          cellHeight = 52;
        } else if (this.screenWidth < 740) {
          cellHeight = 77;
        } else if (this.screenWidth < 990) {
          cellHeight = 65;
        } else if (this.screenWidth < 1390) {
          cellHeight = 77;
        } else {
          cellHeight = 65;
        }
        
        return headerHeight + dayHeaderHeight + (cellHeight * rowCount);
      },

      resetCalendarHeights() {
        const calendarColumn = this.$el.querySelector('.marathon-2025__calendar-column');
        const cells = this.$el.querySelectorAll('.marathon-2025__calendar-day');
        
        if (calendarColumn) {
          calendarColumn.style.minHeight = '';
        }
        
        cells.forEach(cell => {
          cell.style.height = '';
          cell.style.minHeight = '';
        });
      },

      calculateCellHeights(totalHeight) {
        const calendarHeader = this.$el.querySelector('.marathon-2025__calendar-header');
        const dayHeaders = this.$el.querySelectorAll('.marathon-2025__day-header');
        
        if (!calendarHeader || dayHeaders.length === 0) return;
        
        const headerHeight = calendarHeader.offsetHeight;
        const dayHeaderHeight = dayHeaders[0].offsetHeight;
        const availableHeight = totalHeight - headerHeight - dayHeaderHeight;
        const rowCount = Math.ceil(this.getDaysInGrid.length / 7);
        
        if (rowCount === 0) return;
        
        const rowHeight = Math.max(availableHeight / rowCount, 65); // Минимум 65px
        
        const dateGrids = this.$el.querySelectorAll('.marathon-2025__calendar-grid:not(:first-child)');
        dateGrids.forEach(grid => {
          const cells = grid.querySelectorAll('.marathon-2025__calendar-day');
          cells.forEach(cell => {
            cell.style.height = rowHeight + 'px';
            cell.style.minHeight = rowHeight + 'px';
          });
        });
      },

      setupContentObserver() {
        const eventsColumn = this.$el.querySelector('.marathon-2025__events-column');
        if (!eventsColumn) return;
        
        // Отслеживаем изменения содержимого правой колонки
        this.contentObserver = new MutationObserver(() => {
          if (this.screenWidth >= 990) {
            this.syncCalendarHeight();
          }
        });
        
        this.contentObserver.observe(eventsColumn, {
          childList: true,
          subtree: true,
          characterData: true,
          attributes: true
        });
      },

      parseEvents() {
        const eventAttr = this.$el.getAttribute('data-event');
        if (!eventAttr) return;

        try {
          let rawData = JSON.parse(eventAttr);

          this.events = rawData.map(item => ({
            date: this.normalizeBackendDate(item.date),
            events: Array.isArray(item.events) ? item.events : []
          }));

        } catch (e) {
          console.error('Ошибка парсинга data-event', e);
        }
      },

      normalizeBackendDate(backendDateStr) {
        if (!backendDateStr) return '';
        const [y, m, d] = backendDateStr.split('-');
        return `${d}.${m}.${y}`;
      },

      normalizeDate(dateStr) {
        if (!dateStr) return '';
        const [d, m, y] = dateStr.split('.');
        const dd = String(parseInt(d, 10)).padStart(2, '0');
        const mm = String(parseInt(m, 10)).padStart(2, '0');
        return `${dd}.${mm}.${y}`;
      },

      formatDateForData(date) {
        const d = String(date.getDate()).padStart(2, '0');
        const m = String(date.getMonth() + 1).padStart(2, '0');
        const y = date.getFullYear();
        return `${d}.${m}.${y}`;
      },

      formatDate(dateStr) {
        if (!dateStr) return '';
        const normalized = this.normalizeDate(dateStr);
        const [d, m, y] = normalized.split('.').map(Number);
        const months = [
          'января', 'февраля', 'марта', 'апреля', 'мая', 'июня',
          'июля', 'августа', 'сентября', 'октября', 'ноября', 'декабря'
        ];
        return `${d} ${months[m - 1]} ${y}`;
      },

      getEventTypesForDay(day) {
        const sortedEvents = [...day.events].sort((a, b) => {
          const order = [3, 1, 2];
          return order.indexOf(a.type) - order.indexOf(b.type);
        });
        return sortedEvents.map(event => event.type);
      },

      getEventTitleByType(type) {
        const map = {
          1: 'Эфир',
          2: 'Розыгрыш',
          3: 'Тестирование'
        };
        return map[type] || 'Событие';
      },

      getEventTitle(eventObj) {
        return eventObj.title || 'Событие';
      },

      getEventDescription(eventObj) {
        return '';
      },

      selectDay(day) {
        if (!day.hasEvents) return;

        this.selectedDate = day.date;

        const selectedDateObj = this.parseDate(day.date);
        const selectedMonth = selectedDateObj.getMonth();
        const selectedYear = selectedDateObj.getFullYear();

        if (selectedMonth !== this.currentMonth || selectedYear !== this.currentYear) {
          this.currentMonth = selectedMonth;
          this.currentYear = selectedYear;
        }
      },

      isSelected(dateStr) {
        if (!this.selectedDate || !dateStr) return false;
        return this.normalizeDate(this.selectedDate) === this.normalizeDate(dateStr);
      },

      parseDate(dateStr) {
        const normalized = this.normalizeDate(dateStr);
        const [d, m, y] = normalized.split('.').map(Number);
        const date = new Date(y, m - 1, d);

        if (isNaN(date.getTime())) {
          console.warn('Invalid date parsed:', dateStr);
          return new Date(0);
        }

        return date;
      },

      calculateDateBounds() {
        if (this.events.length === 0) {
          const now = new Date();
          this.minDate = this.maxDate = { year: now.getFullYear(), month: now.getMonth() };
          return;
        }

        const dates = this.events.map(e => this.parseDate(e.date));
        const minDate = new Date(Math.min(...dates));
        const maxDate = new Date(Math.max(...dates));

        this.minDate = { year: minDate.getFullYear(), month: minDate.getMonth() };
        this.maxDate = { year: maxDate.getFullYear(), month: maxDate.getMonth() };
      },

      setDefaultMonth() {
        const now = new Date();

        const futureEvents = this.events
          .map(e => ({ ...e, dateObj: this.parseDate(e.date) }))
          .filter(e => e.dateObj >= now)
          .sort((a, b) => a.dateObj - b.dateObj);

        if (futureEvents.length > 0) {
          const targetDate = futureEvents[0].dateObj;
          this.currentYear = targetDate.getFullYear();
          this.currentMonth = targetDate.getMonth();
          return;
        }

        const pastEvents = this.events
          .map(e => ({ ...e, dateObj: this.parseDate(e.date) }))
          .sort((a, b) => b.dateObj - a.dateObj);

        if (pastEvents.length > 0) {
          const targetDate = pastEvents[0].dateObj;
          this.currentYear = targetDate.getFullYear();
          this.currentMonth = targetDate.getMonth();
          return;
        }

        this.currentYear = now.getFullYear();
        this.currentMonth = now.getMonth();
      },

      setDefaultSelection() {
        const now = new Date();

        const futureEvents = this.events
          .filter(e => this.parseDate(e.date) >= now)
          .sort((a, b) => this.parseDate(a.date) - this.parseDate(b.date));

        if (futureEvents.length > 0) {
          this.selectedDate = futureEvents[0].date;
          return;
        }

        const pastEvents = this.events
          .filter(e => this.parseDate(e.date) < now)
          .sort((a, b) => this.parseDate(b.date) - this.parseDate(a.date));

        if (pastEvents.length > 0) {
          this.selectedDate = pastEvents[0].date;
          return;
        }

        this.selectedDate = null;
      },

      prevMonth() {
        if (!this.canGoPrev) return;

        if (this.currentMonth === 0) {
          this.currentMonth = 11;
          this.currentYear--;
        } else {
          this.currentMonth--;
        }
      },

      nextMonth() {
        if (!this.canGoNext) return;

        if (this.currentMonth === 11) {
          this.currentMonth = 0;
          this.currentYear++;
        } else {
          this.currentMonth++;
        }
      }
    },

    watch: {
      eventsForSelectedDay: {
        handler() {
          this.$nextTick(() => {
            if (this.screenWidth >= 990) {
              // Небольшая задержка для стабильности
              setTimeout(() => {
                this.syncCalendarHeight();
              }, 50);
            }
          });
        },
        deep: true
      },
      
      currentMonth() {
        this.$nextTick(() => {
          if (this.screenWidth >= 990) {
            setTimeout(() => {
              this.syncCalendarHeight();
            }, 50);
          }
        });
      }
    },

    mounted() {
      this.parseEvents();
      this.calculateDateBounds();
      this.setDefaultMonth();
      this.setDefaultSelection();
      window.addEventListener('resize', this.updateScreenWidth);
      this.setupContentObserver();
      
      this.$nextTick(() => {
        // Инициализация с задержкой для стабильности
        setTimeout(() => {
          this.syncCalendarHeight();
        }, 100);
      });
    },

    beforeDestroy() {
      window.removeEventListener('resize', this.updateScreenWidth);
      if (this.contentObserver) {
        this.contentObserver.disconnect();
      }
    }
  });
}
