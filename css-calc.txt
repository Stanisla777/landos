methods: {
  receivedDateMobile([year, month]) {
    const dateString = `${year}-${month}`;
    // Используем двойной nextTick для гарантии, что DOM полностью обновлен
    this.$nextTick(() => {
      this.$nextTick(() => {
        const element = this.$refs.mobileShedule.querySelector(`[data-date="${dateString}"]`);
        if (element) {
          this.smoothScrollToElement(element);
        }
      });
    });
  },

  smoothScrollToElement(element) {
    const container = this.$refs.mobileShedule;
    
    // Сначала проверяем, виден ли контейнер
    const containerVisible = this.isElementInViewport(container);
    
    if (!containerVisible) {
      // Если контейнер не виден, сначала скроллим к нему
      container.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
      
      // Ждем завершения скролла к контейнеру
      setTimeout(() => {
        this.scrollInsideContainer(container, element);
      }, 800); // Время должно соответствовать duration анимации
    } else {
      // Если контейнер уже виден, сразу скроллим внутри него
      this.scrollInsideContainer(container, element);
    }
  },

  scrollInsideContainer(container, element) {
    // Вычисляем позицию элемента относительно контейнера
    const elementRect = element.getBoundingClientRect();
    const containerRect = container.getBoundingClientRect();
    
    // Позиция элемента относительно контейнера
    const relativeTop = elementRect.top - containerRect.top;
    
    // Текущая позиция скролла контейнера
    const currentScroll = container.scrollTop;
    
    // Новая позиция скролла (с небольшим отступом сверху)
    const targetScroll = currentScroll + relativeTop - 20; // 20px отступ сверху
    
    // Плавный скролл
    this.animateScroll(container, targetScroll, 600);
  },

  isElementInViewport(el) {
    const rect = el.getBoundingClientRect();
    return (
      rect.top >= 0 &&
      rect.left >= 0 &&
      rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&
      rect.right <= (window.innerWidth || document.documentElement.clientWidth)
    );
  },

  animateScroll(element, targetPosition, duration) {
    const startPosition = element.scrollTop;
    const distance = targetPosition - startPosition;
    let startTime = null;

    const animation = (timestamp) => {
      if (!startTime) startTime = timestamp;
      const progress = timestamp - startTime;
      const percentage = Math.min(progress / duration, 1);
      
      // Кубическая easing функция для плавности
      const easing = t => t<.5 ? 4*t*t*t : (t-1)*(2*t-2)*(2*t-2)+1;
      const scrollNow = startPosition + (distance * easing(percentage));

      element.scrollTop = scrollNow;

      if (progress < duration) {
        window.requestAnimationFrame(animation);
      }
    };

    window.requestAnimationFrame(animation);
  }
}
