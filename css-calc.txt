methods: {
  receivedDateMobile([year, month]) {
    const dateString = `${year}-${month}`;
    this.$nextTick(() => {
      this.$nextTick(() => {
        const element = this.$refs.mobileShedule.querySelector(`[data-date="${dateString}"]`);
        if (element) {
          this.smoothScrollToElement(element);
        }
      });
    });
  },

  async smoothScrollToElement(element) {
    const container = this.$refs.mobileShedule;
    
    // Проверяем, виден ли контейнер
    const containerVisible = this.isElementInViewport(container);
    
    if (!containerVisible) {
      // Плавно скроллим к контейнеру с помощью нашей анимации
      const containerRect = container.getBoundingClientRect();
      const targetScroll = window.scrollY + containerRect.top - 20; // 20px отступ сверху
      await this.animateScroll(window, targetScroll, 600);
    }
    
    // Затем плавно скроллим внутри контейнера
    this.scrollInsideContainer(container, element);
  },

  scrollInsideContainer(container, element) {
    const elementRect = element.getBoundingClientRect();
    const containerRect = container.getBoundingClientRect();
    const relativeTop = elementRect.top - containerRect.top;
    const currentScroll = container.scrollTop;
    const targetScroll = currentScroll + relativeTop - 20; // 20px отступ сверху
    
    this.animateScroll(container, targetScroll, 600);
  },

  isElementInViewport(el) {
    const rect = el.getBoundingClientRect();
    return (
      rect.top >= 0 &&
      rect.bottom <= (window.innerHeight || document.documentElement.clientHeight)
    );
  },

  animateScroll(element, targetPosition, duration) {
    return new Promise(resolve => {
      const startPosition = element.scrollTop || window.scrollY;
      const distance = targetPosition - startPosition;
      let startTime = null;

      const animation = (timestamp) => {
        if (!startTime) startTime = timestamp;
        const progress = timestamp - startTime;
        const percentage = Math.min(progress / duration, 1);
        
        // Кубическая easing функция для плавности
        const easing = t => t<.5 ? 4*t*t*t : (t-1)*(2*t-2)*(2*t-2)+1;
        const scrollNow = startPosition + (distance * easing(percentage));

        if (element === window) {
          window.scrollTo(0, scrollNow);
        } else {
          element.scrollTop = scrollNow;
        }

        if (progress < duration) {
          window.requestAnimationFrame(animation);
        } else {
          resolve();
        }
      };

      window.requestAnimationFrame(animation);
    });
  }
}  


-----------------------------

scrollInsideContainer(container, element) {
  const elementRect = element.getBoundingClientRect();
  const containerRect = container.getBoundingClientRect();
  
  // Проверяем, виден ли элемент в контейнере
  const isVisible = (
    elementRect.top >= containerRect.top &&
    elementRect.bottom <= containerRect.bottom
  );
  
  if (!isVisible) {
    const relativeTop = elementRect.top - containerRect.top;
    const currentScroll = container.scrollTop;
    const targetScroll = currentScroll + relativeTop - 20;
    this.animateScroll(container, targetScroll, 600);
  }
}
