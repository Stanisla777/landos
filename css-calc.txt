receivedDateMobile([year, month]) {
  const dateString = `${year}-${month}`;
  
  // Используем $nextTick + setTimeout для iOS и медленных браузеров
  this.$nextTick(() => {
    setTimeout(() => {
      const container = this.$refs.mobileShedule;
      if (!container) return;

      const element = container.querySelector(`[data-date="${dateString}"]`);
      if (!element) {
        console.warn(`Элемент с data-date="${dateString}" не найден`);
        return;
      }

      // Убедимся, что позиции рассчитаны корректно
      this.$nextTick(() => {
        setTimeout(() => {
          this.scrollToElementSmart(container, element);
        }, 50); // Дополнительная буферизация для iOS
      });
    }, 50);
  });
},

/-----------------------------------------------------------------

scrollToElementSmart(container, targetElement) {
  // Проверка на существование элементов
  if (!container || !targetElement) return;

  // Пересчитываем позиции только сейчас — после всех layout
  const containerRect = container.getBoundingClientRect();
  const targetRect = targetElement.getBoundingClientRect();
  const pageScrollTop = window.scrollY;

  // Позиция элемента относительно контейнера
  const targetTopInContainer = targetRect.top - containerRect.top + container.scrollTop;
  const maxContainerScroll = container.scrollHeight - container.clientHeight;

  // Желаемый скролл контейнера (чтобы элемент был вверху)
  const desiredContainerScroll = Math.max(0, Math.min(targetTopInContainer, maxContainerScroll));

  const canScrollContainer = container.scrollHeight > container.clientHeight;

  if (canScrollContainer) {
    // Скроллим контейнер
    this.smoothScrollTo(container, 'scrollTop', desiredContainerScroll, 300, (val) => {
      container.scrollTop = val;
    });

    // После анимации — подстраиваем страницу, если элемент вне экрана
    setTimeout(() => {
      const finalTargetRect = targetElement.getBoundingClientRect();

      if (finalTargetRect.top < 20 || finalTargetRect.bottom > window.innerHeight - 20) {
        const newPageScrollTop = window.scrollY + finalTargetRect.top - 10;
        this.smoothScrollTo(window, 'scrollY', newPageScrollTop, 300, (val) => {
          window.scrollTo(0, val);
        });
      }
    }, 310);
  } else {
    // Контейнер не скроллится — скроллим страницу
    const targetPageScrollTop = pageScrollTop + targetRect.top - 10;
    this.smoothScrollTo(window, 'scrollY', targetPageScrollTop, 300, (val) => {
      window.scrollTo(0, val);
    });
  }
},

----------------------------------------

Добавить requestAnimationFrame перед getBoundingClientRect()
Это гарантирует, что мы читаем позиции после layout:

// Вместо setTimeout(…, 50), можно использовать в методе receivedDateMobile:
requestAnimationFrame(() => {
  requestAnimationFrame(() => {
    // Теперь точно после layout
    this.scrollToElementSmart(container, element);
  });
});
