export default function contentNote() {
  const notes = document.querySelectorAll('.js--content-note');

  // === Функция сброса inline-стилей тултипа ===
  function resetTooltipStyles(tooltip) {
    if (!tooltip) return;
    tooltip.style.left = '';
    tooltip.style.right = '';
    tooltip.style.top = '';
    tooltip.style.bottom = '';
    tooltip.style.transform = '';
    tooltip.style.inset = '';
  }

  // === Создание мобильного тултипа ===
  function createMobileTooltip(icon, savedScrollY) {
    const textContent = icon.querySelector('.content-note__text')?.textContent || '';
    if (!textContent.trim()) return null;

    const tooltipEl = document.createElement('div');
    tooltipEl.innerHTML = `
      <span class="tooltip-mobile js--tooltip-mobile">
        <div class="select-list__head">
          <p>${textContent}</p>
          <div class="select-list__head-close select-list__css-icon js--close-mobile-tooltip-2"></div>
        </div>
        <div class="select-list__wr-search mor-rep-calculators__wr-search">${textContent}</div>
      </span>
      <div class="select__background select__background-tooltip js--close-mobile-tooltip-2"></div>
    `;

    const tooltipMobile = tooltipEl.querySelector('.tooltip-mobile');
    const closeButtons = tooltipEl.querySelectorAll('.js--close-mobile-tooltip-2');

    // Сохраняем scrollY в замыкании
    closeButtons.forEach(btn => {
      btn.addEventListener('click', () => {
        document.body.appendChild(tooltipEl); // временно добавляем, чтобы удалить
        tooltipEl.remove();
        removeBodyLocked(savedScrollY);
      });
    });

    // Добавляем в body
    document.body.appendChild(tooltipEl);

    // Активируем с анимацией
    requestAnimationFrame(() => {
      tooltipMobile.classList.add('active');
      tooltipEl.querySelector('.select__background-tooltip')?.classList.add('active');
    });

    return tooltipEl;
  }

  // === Закрытие всех мобильных тултипов ===
  function closeAllMobileTooltips() {
    document.querySelectorAll('.tooltip-mobile, .select__background-tooltip').forEach(el => {
      el.closest('div')?.remove();
    });
  }

  // === Вспомогательная функция: добавление класса направления и смещения ===
  function adjustTooltipArrow(icon) {
    const tooltip = icon.querySelector('.content-note__text');
    if (!tooltip) return;

    tooltip.classList.remove('left', 'right');

    const leftStyle = tooltip.style.left;
    const rightStyle = tooltip.style.right;

    if (leftStyle && leftStyle !== 'auto' && leftStyle !== '') {
      tooltip.classList.add('right');
    } else if (rightStyle && rightStyle !== 'auto' && rightStyle !== '') {
      tooltip.classList.add('left');
    }

    if (icon.classList.contains('js--with-arrow')) {
      if (tooltip.classList.contains('right')) {
        const currentLeft = parseFloat(tooltip.style.left) || 0;
        tooltip.style.left = (currentLeft - 6) + 'px';
      }

      const topStyle = tooltip.style.top;
      const bottomStyle = tooltip.style.bottom;

      if (topStyle && topStyle !== 'auto' && topStyle !== '') {
        const currentTop = parseFloat(topStyle) || 0;
        tooltip.style.top = (currentTop + 25) + 'px';
      } else if (bottomStyle && bottomStyle !== 'auto' && bottomStyle !== '') {
        const currentBottom = parseFloat(bottomStyle) || 0;
        tooltip.style.bottom = (currentBottom + 25) + 'px';
      }
    }
  }

  const isIOS = (/(iPad|iPhone|iPod)/.test(navigator.userAgent) && !window.MSStream) ||
    (navigator.userAgent.includes('Mac') && 'ontouchend' in document);

  // === Общий обработчик открытия тултипа ===
  function handleOpenTooltip(e) {
    const target = e.target;
    if (!target.classList.contains('js--content-note')) return;

    const windowWidth = document.body.offsetWidth;

    // Если есть класс .js--ussual-mobile-tooltip — используем старое поведение
    if (target.classList.contains('js--ussual-mobile-tooltip')) {
      // Закрываем все обычные тултипы
      notes.forEach(note => {
        if (note !== target) {
          note.classList.remove('active');
          const textEl = note.querySelector('.content-note__text');
          if (textEl) {
            textEl.classList.remove('active', 'without-arrow');
            resetTooltipStyles(textEl);
          }
        }
      });

      // Открываем текущий обычный тултип
      target.classList.add('active');
      const tooltip = target.querySelector('.content-note__text');
      if (!tooltip) return;
      tooltip.classList.add('active');

      // ... (всё ваше текущее позиционирование для <480px)
      // → оставляем как есть, но только если .js--ussual-mobile-tooltip

      const rect = target.getBoundingClientRect();
      const windowHeight = window.innerHeight;
      const topOffset = rect.top + rect.height / 2;
      const leftOffset = rect.left + rect.width / 2;

      const focusParent = target.closest('.js--focus-on-parent');

      if (focusParent) {
        const parentRect = focusParent.getBoundingClientRect();
        const iconCenterInParent = rect.left - parentRect.left + rect.width / 2;
        const parentCenter = parentRect.width / 2;

        if (iconCenterInParent > parentCenter) {
          tooltip.style.left = 'auto';
          tooltip.style.right = '-4px';
        } else {
          tooltip.style.left = '4px';
          tooltip.style.right = 'auto';
        }

        if (windowWidth < 480) {
          void tooltip.offsetWidth;
          const tRect = tooltip.getBoundingClientRect();
          const doesNotFit = tRect.left < 16 || tRect.right > (windowWidth - 16);

          if (doesNotFit) {
            tooltip.style.inset = 'unset';
            tooltip.style.transform = `translateX(${
              -((rect.left - tooltip.offsetWidth / 2 + 7) - (windowWidth / 2 - tooltip.offsetWidth / 2))
            }px)`;
            tooltip.classList.add('without-arrow');
          } else {
            tooltip.classList.remove('without-arrow');
          }
        }
      } else if (
        target.closest('.js--courses-accord-content') ||
        target.closest('.js--element-overflow') ||
        target.closest('.js--element-overflow-x')
      ) {
        const parent = target.parentElement;
        const parentPos = parent.getBoundingClientRect();
        const relativePosLeftElement = rect.left - parentPos.left;
        const parentWidth = parent.offsetWidth;

        if (parentWidth / 2 < relativePosLeftElement) {
          tooltip.style.left = 'auto';
          tooltip.style.right = '-4px';
        } else {
          tooltip.style.left = '4px';
          tooltip.style.right = 'auto';
        }

        if (windowWidth < 480) {
          void tooltip.offsetWidth;
          const tRect = tooltip.getBoundingClientRect();
          const doesNotFit = tRect.left < 16 || tRect.right > (windowWidth - 16);

          if (doesNotFit) {
            tooltip.style.inset = 'unset';
            tooltip.style.transform = `translateX(${
              -((rect.left - tooltip.offsetWidth / 2 + 7) - (windowWidth / 2 - tooltip.offsetWidth / 2))
            }px)`;
            tooltip.classList.add('without-arrow');
          } else {
            tooltip.classList.remove('without-arrow');
          }
        }
      } else {
        if (windowWidth / 2 < leftOffset) {
          tooltip.style.left = 'auto';
          tooltip.style.right = '-4px';
        } else {
          tooltip.style.left = '4px';
          tooltip.style.right = 'auto';
        }

        if (windowWidth < 480) {
          void tooltip.offsetWidth;
          const tRect = tooltip.getBoundingClientRect();
          const doesNotFit = tRect.left < 16 || tRect.right > (windowWidth - 16);

          if (doesNotFit) {
            tooltip.style.inset = 'unset';
            tooltip.style.transform = `translateX(${
              -((rect.left - tooltip.offsetWidth / 2 + 7) - (windowWidth / 2 - tooltip.offsetWidth / 2))
            }px)`;
            tooltip.classList.add('without-arrow');
          } else {
            tooltip.classList.remove('without-arrow');
          }
        }
      }

      // Вертикальное позиционирование
      if (
        target.closest('.js--courses-accord-content') ||
        target.closest('.js--element-overflow')
      ) {
        const notesParentBounding = target.closest('.js--courses-accord-content').getBoundingClientRect();
        const locationDifference = rect.top - notesParentBounding.top;
        const heightTooltip = tooltip.offsetHeight;
        if (heightTooltip >= locationDifference) {
          tooltip.style.top = 'calc(100% + 4px)';
          tooltip.style.bottom = 'auto';
        } else if (windowHeight / 2 < topOffset) {
          tooltip.style.top = 'auto';
          tooltip.style.bottom = 'calc(100% + 4px)';
        } else {
          tooltip.style.top = 'calc(100% + 4px)';
          tooltip.style.bottom = 'auto';
        }
      } else {
        if (windowHeight / 2 > topOffset) {
          tooltip.classList.remove('up');
          tooltip.classList.add('down');
          tooltip.style.top = 'calc(100% + 4px)';
          tooltip.style.bottom = 'auto';
        } else {
          tooltip.classList.remove('down');
          tooltip.classList.add('up');
          tooltip.style.top = 'auto';
          tooltip.style.bottom = 'calc(100% + 4px)';
        }
      }

      adjustTooltipArrow(target);
      return;
    }

    // === НОВОЕ ПОВЕДЕНИЕ: мобильный тултип на всю ширину ===
    if (windowWidth < 480) {
      // Закрываем все обычные тултипы
      notes.forEach(note => {
        note.classList.remove('active');
        const textEl = note.querySelector('.content-note__text');
        if (textEl) {
          textEl.classList.remove('active', 'without-arrow');
          resetTooltipStyles(textEl);
        }
      });

      // Закрываем другие мобильные тултипы
      closeAllMobileTooltips();

      // Блокируем body и сохраняем scroll
      const savedScrollY = setBodyLocked();

      // Создаём мобильный тултип
      createMobileTooltip(target, savedScrollY);
    }
  }

  // === Закрытие обычных тултипов ===
  function handleCloseTooltip(e) {
    const from = e.relatedTarget || e.toElement;
    const currentTooltip = e.target.closest && e.target.closest('.js--content-note');
    const fromInsideSameTooltip = from && from.closest && from.closest('.js--content-note');

    if (currentTooltip && !fromInsideSameTooltip) {
      currentTooltip.classList.remove('active');
      const textEl = currentTooltip.querySelector('.content-note__text');
      if (textEl) {
        textEl.classList.remove('active', 'without-arrow');
        resetTooltipStyles(textEl);
      }
    }
  }

  // === Обработчики ===
  if (isIOS) {
    document.addEventListener('touchstart', (e) => {
      if (e.target.classList.contains('js--content-note')) {
        handleOpenTooltip(e);
      } else if (!e.target.closest('.tooltip-mobile') && !e.target.closest('.js--content-note')) {
        // Закрыть мобильные тултипы при клике вне
        closeAllMobileTooltips();
        // Разблокировать body — но только если были открыты
        // (в нашем случае разблокировка происходит при клике на крестик/оверлей)
      }
    });
  }

  document.addEventListener('mouseover', (e) => {
    if (e.target.classList.contains('js--content-note')) {
      handleOpenTooltip(e);
    }
  });

  document.addEventListener('mouseout', handleCloseTooltip);

  // Закрытие мобильных тултипов при нажатии Esc
  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
      closeAllMobileTooltips();
      // Разблокировку body мы делаем только через кнопки,
      // потому что не знаем savedScrollY здесь.
      // Но если нужно — можно хранить его в data-атрибуте body.
    }
  });
}
