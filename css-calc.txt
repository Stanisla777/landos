receivedDateMobile([year, month]) {
  const dateString = `${year}-${month}`;
  this.$nextTick(() => {
    const element = this.$refs.mobileShedule.querySelector(`[data-date="${dateString}"]`);
    if (element) {
      this.smoothScrollToElement(element);
    }
  });
},

async smoothScrollToElement(element) {
  const container = this.$refs.mobileShedule;
  
  // Сначала скроллим контейнер в видимую область
  await this.scrollContainerIntoView(container);
  
  // Затем скроллим к элементу внутри контейнера
  await this.scrollToElementInContainer(container, element);
},

async scrollContainerIntoView(container) {
  const containerRect = container.getBoundingClientRect();
  const viewportHeight = window.innerHeight;
  const buffer = 20; // Отступ от краев
  
  // Проверяем, виден ли контейнер
  const containerTop = containerRect.top;
  const containerBottom = containerRect.bottom;
  
  if (containerTop < buffer || containerBottom > viewportHeight - buffer) {
    // Вычисляем позицию для скролла страницы
    const targetScroll = containerTop < buffer 
      ? window.scrollY + containerTop - buffer
      : window.scrollY + containerBottom - viewportHeight + buffer;
    
    await this.animateScroll(window, targetScroll, 600);
  }
},

async scrollToElementInContainer(container, element) {
  const containerRect = container.getBoundingClientRect();
  const elementRect = element.getBoundingClientRect();
  const buffer = 20; // Отступ от краев
  
  // Вычисляем позицию элемента относительно контейнера
  const elementTop = elementRect.top - containerRect.top + container.scrollTop;
  const elementBottom = elementRect.bottom - containerRect.top + container.scrollTop;
  
  const containerHeight = container.clientHeight;
  
  // Вычисляем целевую позицию скролла
  let targetScroll;
  if (elementTop - buffer < container.scrollTop) {
    // Элемент выше видимой области - скроллим вверх
    targetScroll = elementTop - buffer;
  } else if (elementBottom + buffer > container.scrollTop + containerHeight) {
    // Элемент ниже видимой области - скроллим вниз
    targetScroll = elementBottom - containerHeight + buffer;
  } else {
    // Элемент уже виден
    return;
  }
  
  await this.animateScroll(container, targetScroll, 600);
},

animateScroll(element, targetPosition, duration) {
  return new Promise(resolve => {
    const startPosition = element === window 
      ? window.scrollY || window.pageYOffset 
      : element.scrollTop;
    const distance = targetPosition - startPosition;
    let startTime = null;

    const animation = (timestamp) => {
      if (!startTime) startTime = timestamp;
      const progress = timestamp - startTime;
      const percentage = Math.min(progress / duration, 1);

      // Кубическая easing функция для плавности
      const easing = t => t<.5 ? 4*t*t*t : (t-1)*(2*t-2)*(2*t-2)+1;
      const scrollNow = startPosition + (distance * easing(percentage));

      if (element === window) {
        window.scrollTo(0, scrollNow);
      } else {
        element.scrollTop = scrollNow;
      }

      if (progress < duration) {
        window.requestAnimationFrame(animation);
      } else {
        resolve();
      }
    };

    window.requestAnimationFrame(animation);
  });
}
