receivedDateMobile([year, month]) {
  const dateString = `${year}-${month}`;
  this.$nextTick(() => {
    const element = this.$refs.mobileShedule.querySelector(`[data-date="${dateString}"]`);
    if (element) {
      this.smoothScrollToElement(element);
    }
  });
},

methods: {
  smoothScrollToElement(element) {
    // Получаем контейнер с скроллом (либо document для основного скролла)
    const container = this.$refs.mobileShedule;
    const isContainerScrollable = container.scrollHeight > container.clientHeight;
    
    const targetScroll = isContainerScrollable 
      ? container.scrollTop + element.getBoundingClientRect().top - container.getBoundingClientRect().top
      : window.scrollY + element.getBoundingClientRect().top;
    
    const startPosition = isContainerScrollable ? container.scrollTop : window.scrollY;
    const distance = targetScroll - startPosition;
    const duration = 500; // Длительность анимации в мс
    let startTime = null;
    
    const animateScroll = (timestamp) => {
      if (!startTime) startTime = timestamp;
      const progress = timestamp - startTime;
      const percentage = Math.min(progress / duration, 1);
      
      // Кубическая функция для плавности
      const easing = percentage < 0.5 
        ? 4 * percentage * percentage * percentage 
        : 1 - Math.pow(-2 * percentage + 2, 3) / 2;
      
      const scrollPosition = startPosition + distance * easing;
      
      if (isContainerScrollable) {
        container.scrollTop = scrollPosition;
      } else {
        window.scrollTo(0, scrollPosition);
      }
      
      if (progress < duration) {
        window.requestAnimationFrame(animateScroll);
      }
    };
    
    window.requestAnimationFrame(animateScroll);
  }
}
