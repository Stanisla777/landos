receivedDateMobile([year, month]) {
  const dateString = `${year}-${month}`;
  this.$nextTick(() => {
    const container = this.$refs.mobileShedule; // контейнер с max-height и overflow
    const element = container.querySelector(`[data-date="${dateString}"]`);

    if (!element) return;

    this.$nextTick(() => {
      // Попробуем проскроллить элемент вверх контейнера
      element.scrollIntoView({
        block: 'start',
        inline: 'nearest',
        behavior: 'smooth'
      });

      // После анимации (или сразу, если поведение не 'auto') проверим видимость
      // Но так как поведение 'smooth' — мы не можем точно знать, когда закончится
      // Поэтому используем небольшой setTimeout как fallback
      setTimeout(() => {
        const containerRect = container.getBoundingClientRect();
        const elementRect = element.getBoundingClientRect();

        // Проверим, находится ли элемент **в пределах контейнера**
        const isElementInContainer =
          elementRect.top >= containerRect.top &&
          elementRect.bottom <= containerRect.bottom;

        if (!isElementInContainer) {
          // Элемент не полностью в контейнере — скроллим страницу, чтобы контейнер влез
          container.scrollIntoView({
            block: 'start',
            behavior: 'smooth'
          });
        }
      }, 100); // 100мс — минимальная задержка, чтобы scrollIntoView начал работать
    });
  });
}
