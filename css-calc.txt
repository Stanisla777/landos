receivedDateMobile([year, month]) {
  const dateString = `${year}-${month}`;
  this.$nextTick(() => {
    const element = this.$refs.mobileShedule.querySelector(`[data-date="${dateString}"]`);
    if (element) {
      this.smoothScrollToElement(element);
    }
  });
},

async smoothScrollToElement(element) {
  const container = this.$refs.mobileShedule;
  
  // Сначала убедимся, что контейнер виден в viewport
  await this.scrollContainerIntoView(container);
  
  // Даем браузеру время на отрисовку после скролла страницы
  await new Promise(resolve => setTimeout(resolve, 50));
  
  // Затем скроллим внутри контейнера
  await this.scrollToElementInContainer(container, element);
},

async scrollContainerIntoView(container) {
  // Получаем актуальные координаты после возможных изменений DOM
  const containerRect = container.getBoundingClientRect();
  const viewportHeight = window.innerHeight;
  
  // Вычисляем сколько контейнера видно
  const visibleHeight = Math.min(containerRect.bottom, viewportHeight) - Math.max(containerRect.top, 0);
  const visibilityRatio = visibleHeight / containerRect.height;
  
  // Если видно меньше 80% контейнера, скроллим страницу
  if (visibilityRatio < 0.8) {
    // Центрируем контейнер в viewport
    const targetScroll = window.scrollY + containerRect.top - (viewportHeight - containerRect.height) / 2;
    await this.animateScroll(window, targetScroll, 600);
  }
},

async scrollToElementInContainer(container, element) {
  // Получаем актуальные координаты после возможных изменений DOM
  const containerRect = container.getBoundingClientRect();
  const elementRect = element.getBoundingClientRect();
  
  // Вычисляем позицию элемента относительно контейнера
  const elementTopRelative = elementRect.top - containerRect.top + container.scrollTop;
  const elementBottomRelative = elementRect.bottom - containerRect.top + container.scrollTop;
  
  const containerHeight = container.clientHeight;
  const buffer = 20; // Отступ
  
  // Вычисляем целевую позицию скролла
  let targetScroll;
  if (elementTopRelative - buffer < container.scrollTop) {
    // Элемент выше видимой области - скроллим чтобы элемент был сверху с отступом
    targetScroll = elementTopRelative - buffer;
  } else if (elementBottomRelative + buffer > container.scrollTop + containerHeight) {
    // Элемент ниже видимой области - скроллим чтобы элемент был снизу с отступом
    targetScroll = elementBottomRelative - containerHeight + buffer;
  } else {
    // Элемент уже виден
    return;
  }
  
  // Ограничиваем целевую позицию допустимыми значениями
  targetScroll = Math.max(0, Math.min(targetScroll, container.scrollHeight - containerHeight));
  
  await this.animateScroll(container, targetScroll, 600);
},

animateScroll(element, targetPosition, duration) {
  return new Promise(resolve => {
    const startPosition = element === window ? window.scrollY : element.scrollTop;
    const distance = targetPosition - startPosition;
    
    // Если расстояние слишком мало, не анимируем
    if (Math.abs(distance) < 2) {
      if (element === window) {
        window.scrollTo(0, targetPosition);
      } else {
        element.scrollTop = targetPosition;
      }
      return resolve();
    }
    
    let startTime = null;

    const animation = (timestamp) => {
      if (!startTime) startTime = timestamp;
      const progress = timestamp - startTime;
      const percentage = Math.min(progress / duration, 1);

      // Кубическая easing функция для плавности
      const easing = t => t<.5 ? 4*t*t*t : (t-1)*(2*t-2)*(2*t-2)+1;
      const scrollNow = startPosition + (distance * easing(percentage));

      if (element === window) {
        window.scrollTo(0, scrollNow);
      } else {
        element.scrollTop = scrollNow;
      }

      if (progress < duration) {
        window.requestAnimationFrame(animation);
      } else {
        resolve();
      }
    };

    window.requestAnimationFrame(animation);
  });
}
