.calc-tax-deduc-new__area.mor-rep-calculators__shedule-calendar-mobile-container(
  ref="mobileShedule"
  @scroll.passive="handleScroll"
)
  //- ваш контент

methods: {
  receivedDateMobile([year, month]) {
    const dateString = `${year}-${month}`;
    this.$nextTick(() => {
      const element = this.$refs.mobileShedule.querySelector(`[data-date="${dateString}"]`);
      
      if (element) {
        setTimeout(() => {
          this.scrollToElement(element);
        }, 20);
      }
    });
  },
  
  scrollToElement(element) {
    const container = this.$refs.mobileShedule;
    const containerRect = container.getBoundingClientRect();
    const elementRect = element.getBoundingClientRect();
    
    // Проверяем, есть ли скролл у контейнера
    const hasContainerScroll = container.scrollHeight > container.clientHeight;
    
    if (hasContainerScroll) {
      // Если элемент не виден в контейнере, скроллим контейнер
      if (elementRect.top < containerRect.top || elementRect.bottom > containerRect.bottom) {
        const scrollTop = element.offsetTop - container.offsetTop - (container.clientHeight - element.clientHeight) / 2;
        container.scrollTo({ top: scrollTop });
      }
    } else {
      // Если скролла у контейнера нет, скроллим страницу
      const scrollPosition = window.pageYOffset + elementRect.top - (window.innerHeight - elementRect.height) / 2;
      
      // Используем requestAnimationFrame для плавного скролла без behavior: 'smooth'
      this.smoothScrollTo(scrollPosition);
    }
  },
  
  smoothScrollTo(targetPosition) {
    const startPosition = window.pageYOffset;
    const distance = targetPosition - startPosition;
    const duration = 300;
    let startTime = null;
    
    const animation = (currentTime) => {
      if (!startTime) startTime = currentTime;
      const timeElapsed = currentTime - startTime;
      const run = this.easeInOutQuad(timeElapsed, startPosition, distance, duration);
      window.scrollTo(0, run);
      if (timeElapsed < duration) {
        requestAnimationFrame(animation);
      }
    };
    
    requestAnimationFrame(animation);
  },
  
  easeInOutQuad(t, b, c, d) {
    t /= d / 2;
    if (t < 1) return c / 2 * t * t + b;
    t--;
    return -c / 2 * (t * (t - 2) - 1) + b;
  },
  
  handleScroll(event) {
    // Предотвращаем скролл страницы, если скроллится контейнер
    if (event.target === this.$refs.mobileShedule) {
      event.stopPropagation();
    }
  }
}



Если вам нужно дополнительно учитывать случаи, когда элемент находится внизу контейнера и требует скролла страницы, можно модифицировать условие в scrollToElement:

javascript
if (hasContainerScroll) {
  const elementBottomRelative = elementRect.bottom - containerRect.top;
  if (elementRect.top < containerRect.top || elementBottomRelative > container.clientHeight) {
    const scrollTop = Math.min(
      element.offsetTop - container.offsetTop,
      container.scrollHeight - container.clientHeight
    );
    container.scrollTo({ top: scrollTop });
  }
} else {
  // ...
}
