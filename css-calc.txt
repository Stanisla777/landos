receivedDateMobile([year, month]) {
  const dateString = `${year}-${month}`;
  this.$nextTick(() => {
    const container = this.$refs.mobileShedule;
    const element = container.querySelector(`[data-date="${dateString}"]`);
    
    if (!element) return;

    // Функция для плавного скролла
    const smoothScroll = (target, offset = 0) => {
      const startPosition = target.scrollTop;
      const targetPosition = offset;
      const distance = targetPosition - startPosition;
      const duration = 500; // продолжительность в ms
      let startTime = null;

      const animation = (currentTime) => {
        if (!startTime) startTime = currentTime;
        const timeElapsed = currentTime - startTime;
        const run = easeInOutQuad(timeElapsed, startPosition, distance, duration);
        target.scrollTop = run;
        if (timeElapsed < duration) {
          requestAnimationFrame(animation);
        }
      };

      // Функция для плавности
      const easeInOutQuad = (t, b, c, d) => {
        t /= d / 2;
        if (t < 1) return c / 2 * t * t + b;
        t--;
        return -c / 2 * (t * (t - 2) - 1) + b;
      };

      requestAnimationFrame(animation);
    };

    // Проверяем, виден ли элемент в viewport
    const containerRect = container.getBoundingClientRect();
    const elementRect = element.getBoundingClientRect();

    // Если элемент выше контейнера
    if (elementRect.top < containerRect.top) {
      // Сначала скроллим контейнер в окне
      smoothScroll(document.documentElement, container.offsetTop);
      
      // Затем скроллим внутри контейнера с небольшой задержкой
      setTimeout(() => {
        smoothScroll(container, element.offsetTop - container.offsetTop);
      }, 500);
    } 
    // Если элемент ниже контейнера
    else if (elementRect.bottom > containerRect.bottom) {
      // Сначала скроллим контейнер в окне
      smoothScroll(document.documentElement, container.offsetTop + container.offsetHeight - window.innerHeight);
      
      // Затем скроллим внутри контейнера с небольшой задержкой
      setTimeout(() => {
        smoothScroll(container, element.offsetTop - container.offsetTop - (container.offsetHeight - element.offsetHeight));
      }, 500);
    } 
    // Если элемент виден, просто скроллим внутри контейнера
    else {
      smoothScroll(container, element.offsetTop - container.offsetTop);
    }
  });
}
