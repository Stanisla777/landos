data-event='[{"date":"05.09.2025","type":[{"kefir":"Эфир со спикерами"},{"rozigrish":"Розыгрыш"}]}, {"date":"10.09.2025","type":[{"kefir":"Эфир со спикерами"},{"rozigrish":"Розыгрыш"}]}, {"date":"18.10.2025","type":[{"kefir":"Эфир со спикерами"},{"rozigrish":"Розыгрыш"}]}]'

<template>
  <div class="schedule-block">
    <!-- Левая колонка: календарь -->
    <div class="calendar-column">
      <div class="calendar-header">
        <button @click="prevMonth">←</button>
        <h3>{{ currentMonthName }} {{ currentYear }}</h3>
        <button @click="nextMonth">→</button>
      </div>
      <div class="calendar-grid">
        <div class="day-header" v-for="day in weekdays" :key="day">{{ day }}</div>
        <div
          v-for="day in daysInMonth"
          :key="day.date"
          :class="{
            'calendar-day': true,
            'disabled': !day.hasEvents,
            'selected': isSelected(day.date)
          }"
          @click="selectDay(day)"
        >
          {{ day.number }}
          <div v-if="day.hasEvents" class="event-indicators">
            <span v-for="eventType in getEventTypes(day.date)" :key="eventType" class="event-dot" :class="eventType"></span>
          </div>
        </div>
      </div>
    </div>

    <!-- Правая колонка: детали событий -->
    <div class="events-column" v-if="selectedDate">
      <h4>События на {{ formatDate(selectedDate) }}</h4>
      <div v-for="(event, index) in eventsForSelectedDay" :key="index" class="event-item">
        <strong>{{ getEventTitle(event) }}</strong>
        <p>{{ getEventDescription(event) }}</p>
      </div>
    </div>
  </div>
</template>




export default {
  name: 'EventCalendar',
  data() {
    return {
      currentMonth: new Date().getMonth(),
      currentYear: new Date().getFullYear(),
      selectedDate: null,
      events: [], // распарсенные события
    };
  },
  computed: {
    weekdays() {
      return ['Пн', 'Вт', 'Ср', 'Чт', 'Пт', 'Сб', 'Вс'];
    },
    currentMonthName() {
      const months = [
        'Январь', 'Февраль', 'Март', 'Апрель', 'Май', 'Июнь',
        'Июль', 'Август', 'Сентябрь', 'Октябрь', 'Ноябрь', 'Декабрь'
      ];
      return months[this.currentMonth];
    },
    daysInMonth() {
      const days = [];
      const firstDay = new Date(this.currentYear, this.currentMonth, 1).getDay(); // 0 = воскресенье
      const daysInMonth = new Date(this.currentYear, this.currentMonth + 1, 0).getDate();

      // Пустые ячейки до первого дня месяца
      for (let i = 0; i < (firstDay === 0 ? 6 : firstDay - 1); i++) {
        days.push({ number: '', date: null, hasEvents: false });
      }

      // Ячейки с днями месяца
      for (let day = 1; day <= daysInMonth; day++) {
        const dateStr = this.formatDateForData(new Date(this.currentYear, this.currentMonth, day));
        const dayEvents = this.events.find(e => e.date === dateStr);
        days.push({
          number: day,
          date: dateStr,
          hasEvents: !!dayEvents
        });
      }

      return days;
    },
    eventsForSelectedDay() {
      if (!this.selectedDate) return [];
      const dayData = this.events.find(e => e.date === this.selectedDate);
      return dayData ? dayData.type : [];
    }
  },
  mounted() {
    this.parseEvents();
    this.setDefaultSelection();
  },
  methods: {
    parseEvents() {
      const eventAttr = this.$el.parentElement.getAttribute('data-event');
      if (!eventAttr) return;
      try {
        this.events = JSON.parse(eventAttr);
      } catch (e) {
        console.error('Ошибка парсинга data-event', e);
      }
    },
    formatDateForData(date) {
      const d = String(date.getDate()).padStart(2, '0');
      const m = String(date.getMonth() + 1).padStart(2, '0');
      const y = date.getFullYear();
      return `${d}.${m}.${y}`;
    },
    formatDate(dateStr) {
      return dateStr; // можно распарсить и отформатировать красиво
    },
    getEventTypes(dateStr) {
      const day = this.events.find(e => e.date === dateStr);
      if (!day) return [];
      return day.type.map(item => Object.keys(item)[0]); // ['kefir', 'rozigrish']
    },
    getEventTitle(eventObj) {
      const key = Object.keys(eventObj)[0];
      const map = {
        kefir: 'Эфир',
        rozigrish: 'Розыгрыш',
        test: 'Тестирование'
      };
      return map[key] || key;
    },
    getEventDescription(eventObj) {
      const key = Object.keys(eventObj)[0];
      return eventObj[key];
    },
    selectDay(day) {
      if (!day.hasEvents) return;
      this.selectedDate = day.date;
    },
    isSelected(dateStr) {
      return this.selectedDate === dateStr;
    },
    prevMonth() {
      if (this.currentMonth === 0) {
        this.currentMonth = 11;
        this.currentYear--;
      } else {
        this.currentMonth--;
      }
      this.setDefaultSelection();
    },
    nextMonth() {
      if (this.currentMonth === 11) {
        this.currentMonth = 0;
        this.currentYear++;
      } else {
        this.currentMonth++;
      }
      this.setDefaultSelection();
    },
    setDefaultSelection() {
      // 1. Текущая дата
      const today = this.formatDateForData(new Date());
      const todayEvent = this.events.find(e => e.date === today);
      if (todayEvent) {
        this.selectedDate = today;
        return;
      }

      // 2. Ближайший будущий день с событием
      const futureEvents = this.events.filter(e => {
        const eventDate = this.parseDate(e.date);
        return eventDate > new Date();
      }).sort((a, b) => this.parseDate(a.date) - this.parseDate(b.date));

      if (futureEvents.length > 0) {
        this.selectedDate = futureEvents[0].date;
        return;
      }

      // 3. Последний прошедший день с событием
      const pastEvents = this.events.filter(e => {
        const eventDate = this.parseDate(e.date);
        return eventDate < new Date();
      }).sort((a, b) => this.parseDate(b.date) - this.parseDate(a.date));

      if (pastEvents.length > 0) {
        this.selectedDate = pastEvents[0].date;
        return;
      }

      // 4. Ничего не выбрано
      this.selectedDate = null;
    },
    parseDate(dateStr) {
      const [d, m, y] = dateStr.split('.').map(Number);
      return new Date(y, m - 1, d);
    }
  }
};




.schedule-block {
  display: flex;
  gap: 20px;
}

.calendar-column {
  flex: 1;
}

.calendar-grid {
  display: grid;
  grid-template-columns: repeat(7, 1fr);
  gap: 4px;
}

.calendar-day {
  padding: 10px;
  border: 1px solid #ccc;
  cursor: pointer;
  position: relative;
}

.calendar-day.disabled {
  color: #ccc;
  cursor: not-allowed;
  background: #f5f5f5;
}

.calendar-day.selected {
  background: #e3f2fd;
  border-color: #2196f3;
}

.event-indicators {
  display: flex;
  gap: 2px;
  margin-top: 4px;
}

.event-dot {
  width: 6px;
  height: 6px;
  border-radius: 50%;
  display: inline-block;
}

.event-dot.kefir { background: #ff5722; }
.event-dot.rozigrish { background: #4caf50; }
.event-dot.test { background: #2196f3; }

.events-column {
  flex: 1;
  padding: 10px;
  border-left: 1px solid #ddd;
}

