methods: {
  parseEvents() {
    const eventAttr = this.$el.getAttribute('data-event')
    if (!eventAttr) return;

    try {
      let rawData = JSON.parse(eventAttr);

      this.events = rawData.map(item => ({
        date: this.normalizeBackendDate(item.date),
        events: Array.isArray(item.events) ? item.events : []
      }));

    } catch (e) {
      console.error('Ошибка парсинга data-event', e);
    }
  },

  normalizeBackendDate(backendDateStr) {
    if (!backendDateStr) return '';
    const [y, m, d] = backendDateStr.split('-');
    return `${d}.${m}.${y}`;
  },

  normalizeDate(dateStr) {
    if (!dateStr) return '';
    const [d, m, y] = dateStr.split('.');
    const dd = String(parseInt(d, 10)).padStart(2, '0');
    const mm = String(parseInt(m, 10)).padStart(2, '0');
    return `${dd}.${mm}.${y}`;
  },

  formatDateForData(date) {
    const d = String(date.getDate()).padStart(2, '0');
    const m = String(date.getMonth() + 1).padStart(2, '0');
    const y = date.getFullYear();
    return `${d}.${m}.${y}`;
  },

  // ➤ ИСПРАВЛЕНИЕ: добавлен метод formatDate для шаблона
  formatDate(dateStr) {
    if (!dateStr) return '';
    const normalized = this.normalizeDate(dateStr);
    const [d, m, y] = normalized.split('.').map(Number);
    const months = [
      'января', 'февраля', 'марта', 'апреля', 'мая', 'июня',
      'июля', 'августа', 'сентября', 'октября', 'ноября', 'декабря'
    ];
    return `${d} ${months[m - 1]} ${y}`;
  },

  getEventTypesForDay(day) {
    return day.events.map(event => event.type);
  },

  getEventTitleByType(type) {
    const map = {
      1: 'Эфир',
      2: 'Розыгрыш',
      3: 'Тестирование'
    };
    return map[type] || 'Событие';
  },

  getEventTitle(eventObj) {
    return eventObj.title || 'Событие';
  },

  getEventDescription(eventObj) {
    return '';
  },

  selectDay(day) {
    if (!day.hasEvents) return;
    this.selectedDate = day.date;
  },

  isSelected(dateStr) {
    if (!this.selectedDate || !dateStr) return false;
    return this.normalizeDate(this.selectedDate) === this.normalizeDate(dateStr);
  },

  parseDate(dateStr) {
    const normalized = this.normalizeDate(dateStr);
    const [d, m, y] = normalized.split('.').map(Number);
    const date = new Date(y, m - 1, d);

    if (isNaN(date.getTime())) {
      console.warn('Invalid date parsed:', dateStr);
      return new Date(0);
    }

    return date;
  },

  calculateDateBounds() {
    if (this.events.length === 0) {
      const now = new Date();
      this.minDate = this.maxDate = { year: now.getFullYear(), month: now.getMonth() };
      return;
    }

    const dates = this.events.map(e => this.parseDate(e.date));
    const minDate = new Date(Math.min(...dates));
    const maxDate = new Date(Math.max(...dates));

    this.minDate = { year: minDate.getFullYear(), month: minDate.getMonth() };
    this.maxDate = { year: maxDate.getFullYear(), month: maxDate.getMonth() };
  },

  setDefaultMonth() {
    const now = new Date();

    const futureEvents = this.events
      .map(e => ({ ...e, dateObj: this.parseDate(e.date) }))
      .filter(e => e.dateObj >= now)
      .sort((a, b) => a.dateObj - b.dateObj);

    if (futureEvents.length > 0) {
      const targetDate = futureEvents[0].dateObj;
      this.currentYear = targetDate.getFullYear();
      this.currentMonth = targetDate.getMonth();
      return;
    }

    const pastEvents = this.events
      .map(e => ({ ...e, dateObj: this.parseDate(e.date) }))
      .sort((a, b) => b.dateObj - a.dateObj);

    if (pastEvents.length > 0) {
      const targetDate = pastEvents[0].dateObj;
      this.currentYear = targetDate.getFullYear();
      this.currentMonth = targetDate.getMonth();
      return;
    }

    this.currentYear = now.getFullYear();
    this.currentMonth = now.getMonth();
  },

  setDefaultSelection() {
    const now = new Date();

    const futureEvents = this.events
      .filter(e => this.parseDate(e.date) >= now)
      .sort((a, b) => this.parseDate(a.date) - this.parseDate(b.date));

    if (futureEvents.length > 0) {
      this.selectedDate = futureEvents[0].date;
      return;
    }

    const pastEvents = this.events
      .filter(e => this.parseDate(e.date) < now)
      .sort((a, b) => this.parseDate(b.date) - this.parseDate(a.date));

    if (pastEvents.length > 0) {
      this.selectedDate = pastEvents[0].date;
      return;
    }

    this.selectedDate = null;
  },

  prevMonth() {
    if (!this.canGoPrev) return;

    if (this.currentMonth === 0) {
      this.currentMonth = 11;
      this.currentYear--;
    } else {
      this.currentMonth--;
    }
  },

  nextMonth() {
    if (!this.canGoNext) return;

    if (this.currentMonth === 11) {
      this.currentMonth = 0;
      this.currentYear++;
    } else {
      this.currentMonth++;
    }
  }
}
