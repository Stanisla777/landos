.marathon-2025__shedule#marathon-2025-shedule(
  v-cloak
  ref="Shedule2025"
  data-event='[{"date":"2023-09-13", "events":[{"type":1, "title":"–≠—Ñ–∏—Ä"},{"type":2, "title":"–†–æ–∑—ã–≥—Ä—ã—à"},{"type":3, "title":"–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ"}]}, {"date":"2023-09-22", "events":[{"type":2, "title":"–†–æ–∑—ã–≥—Ä—ã—à"},{"type":3, "title":"–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ"}]}]'
)
  .schedule-block
    .calendar-column
      .calendar-header
        button(@click="prevMonth" :disabled="!canGoPrev") ‚Üê
        h3 {{ currentMonthName }} {{ currentYear }}
        button(@click="nextMonth" :disabled="!canGoNext") ‚Üí
      .calendar-grid
        .day-header(v-for="day in weekdays" :key="day") {{ day }}
        .calendar-day(
          v-for="day in getDaysInGrid"
          :key="day.date"
          :class="{
            'disabled': !day.hasEvents,
            'selected': isSelected(day.date),
            'prev-month': day.isPrevMonth,
            'next-month': day.isNextMonth
          }"
          @click="selectDay(day)"
        )
          .day-number {{ day.number }}
          .event-icons(v-if="day.hasEvents")
            span.event-icon(
              v-for="eventType in getEventTypesForDay(day)"
              :key="eventType"
              :class="'icon-type-' + eventType"
              :title="getEventTitleByType(eventType)"
            )
              // –°—é–¥–∞ –≤—Å—Ç–∞–≤—å —Å–≤–æ–∏ –∏–∫–æ–Ω–∫–∏, –Ω–∞–ø—Ä–∏–º–µ—Ä:
              // i(:class="getIconClass(eventType)")
              // –∏–ª–∏
              // img(:src="getIconSrc(eventType)" :alt="getEventTitleByType(eventType)")

    .events-column(v-if="selectedDate")
      h4 –°–æ–±—ã—Ç–∏—è –Ω–∞ {{ formatDate(selectedDate) }}
      .event-item(
        v-for="(event, index) in eventsForSelectedDay"
        :key="index"
      )
        strong {{ getEventTitle(event) }}
        p {{ getEventDescription(event) }}


--------------------------------------------------

export default function marathon2025Shedule() {
  const app = new Vue({
    el: '#marathon-2025-shedule',
    data: {
      currentMonth: null,
      currentYear: null,
      selectedDate: null,
      events: [],
      minDate: null,
      maxDate: null,
    },
    computed: {
      weekdays() {
        return ['–ü–Ω', '–í—Ç', '–°—Ä', '–ß—Ç', '–ü—Ç', '–°–±', '–í—Å'];
      },
      currentMonthName() {
        const months = [
          '–Ø–Ω–≤–∞—Ä—å', '–§–µ–≤—Ä–∞–ª—å', '–ú–∞—Ä—Ç', '–ê–ø—Ä–µ–ª—å', '–ú–∞–π', '–ò—é–Ω—å',
          '–ò—é–ª—å', '–ê–≤–≥—É—Å—Ç', '–°–µ–Ω—Ç—è–±—Ä—å', '–û–∫—Ç—è–±—Ä—å', '–ù–æ—è–±—Ä—å', '–î–µ–∫–∞–±—Ä—å'
        ];
        return months[this.currentMonth];
      },

      // üÜï –û—Å–Ω–æ–≤–Ω–æ–π –º–µ—Ç–æ–¥ ‚Äî –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç 42 –¥–Ω—è (6 —Å—Ç—Ä–æ–∫ √ó 7 –¥–Ω–µ–π)
      getDaysInGrid() {
        const days = [];
        const firstDay = new Date(this.currentYear, this.currentMonth, 1).getDay(); // 0 = –≤—Å
        const daysInMonth = new Date(this.currentYear, this.currentMonth + 1, 0).getDate();

        // ‚Äî‚Äî‚Äî –î–Ω–∏ –ø—Ä–µ–¥—ã–¥—É—â–µ–≥–æ –º–µ—Å—è—Ü–∞ ‚Äî‚Äî‚Äî
        const prevMonth = this.currentMonth === 0 ? 11 : this.currentMonth - 1;
        const prevYear = this.currentMonth === 0 ? this.currentYear - 1 : this.currentYear;
        const daysInPrevMonth = new Date(prevYear, prevMonth + 1, 0).getDate();

        // –°–∫–æ–ª—å–∫–æ –¥–Ω–µ–π –ø—Ä–µ–¥—ã–¥—É—â–µ–≥–æ –º–µ—Å—è—Ü–∞ –Ω—É–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å
        const prevDaysCount = firstDay === 0 ? 6 : firstDay - 1;

        for (let i = 0; i < prevDaysCount; i++) {
          const dayNumber = daysInPrevMonth - (prevDaysCount - 1 - i);
          const date = new Date(prevYear, prevMonth, dayNumber);
          const dateStr = this.formatDateForData(date);
          const normalizedDate = this.normalizeDate(dateStr);
          const eventItem = this.events.find(e => this.normalizeDate(e.date) === normalizedDate);

          days.push({
            number: dayNumber,
            date: dateStr,
            isPrevMonth: true,
            isNextMonth: false,
            hasEvents: !!eventItem,
            events: eventItem ? eventItem.events : []
          });
        }

        // ‚Äî‚Äî‚Äî –î–Ω–∏ —Ç–µ–∫—É—â–µ–≥–æ –º–µ—Å—è—Ü–∞ ‚Äî‚Äî‚Äî
        for (let day = 1; day <= daysInMonth; day++) {
          const date = new Date(this.currentYear, this.currentMonth, day);
          const dateStr = this.formatDateForData(date);
          const normalizedDate = this.normalizeDate(dateStr);
          const eventItem = this.events.find(e => this.normalizeDate(e.date) === normalizedDate);

          days.push({
            number: day,
            date: dateStr,
            isPrevMonth: false,
            isNextMonth: false,
            hasEvents: !!eventItem,
            events: eventItem ? eventItem.events : []
          });
        }

        // ‚Äî‚Äî‚Äî –î–Ω–∏ —Å–ª–µ–¥—É—é—â–µ–≥–æ –º–µ—Å—è—Ü–∞ ‚Äî‚Äî‚Äî
        const nextMonth = this.currentMonth === 11 ? 0 : this.currentMonth + 1;
        const nextYear = this.currentMonth === 11 ? this.currentYear + 1 : this.currentYear;

        // –î–æ–∑–∞–ø–æ–ª–Ω—è–µ–º –¥–æ 42 —è—á–µ–µ–∫
        while (days.length < 42) {
          const dayNumber = days.length - daysInMonth - prevDaysCount + 1;
          const date = new Date(nextYear, nextMonth, dayNumber);
          const dateStr = this.formatDateForData(date);
          const normalizedDate = this.normalizeDate(dateStr);
          const eventItem = this.events.find(e => this.normalizeDate(e.date) === normalizedDate);

          days.push({
            number: dayNumber,
            date: dateStr,
            isPrevMonth: false,
            isNextMonth: true,
            hasEvents: !!eventItem,
            events: eventItem ? eventItem.events : []
          });
        }

        return days;
      },

      eventsForSelectedDay() {
        if (!this.selectedDate) return [];
        const normalized = this.normalizeDate(this.selectedDate);
        const dayData = this.events.find(e => this.normalizeDate(e.date) === normalized);
        return dayData ? dayData.events : [];
      },

      canGoPrev() {
        if (!this.minDate) return false;
        const current = this.currentYear * 12 + this.currentMonth;
        const min = this.minDate.year * 12 + this.minDate.month;
        return current > min;
      },

      canGoNext() {
        if (!this.maxDate) return false;
        const current = this.currentYear * 12 + this.currentMonth;
        const max = this.maxDate.year * 12 + this.maxDate.month;
        return current < max;
      }
    },

    methods: {
      parseEvents() {
        const eventAttr = this.$el.getAttribute('data-event');
        if (!eventAttr) return;

        try {
          let rawData = JSON.parse(eventAttr);

          this.events = rawData.map(item => ({
            date: this.normalizeBackendDate(item.date),
            events: Array.isArray(item.events) ? item.events : []
          }));

        } catch (e) {
          console.error('–û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ data-event', e);
        }
      },

      normalizeBackendDate(backendDateStr) {
        if (!backendDateStr) return '';
        const [y, m, d] = backendDateStr.split('-');
        return `${d}.${m}.${y}`;
      },

      normalizeDate(dateStr) {
        if (!dateStr) return '';
        const [d, m, y] = dateStr.split('.');
        const dd = String(parseInt(d, 10)).padStart(2, '0');
        const mm = String(parseInt(m, 10)).padStart(2, '0');
        return `${dd}.${mm}.${y}`;
      },

      formatDateForData(date) {
        const d = String(date.getDate()).padStart(2, '0');
        const m = String(date.getMonth() + 1).padStart(2, '0');
        const y = date.getFullYear();
        return `${d}.${m}.${y}`;
      },

      // ‚û§ –î–ª—è —à–∞–±–ª–æ–Ω–∞ ‚Äî –∫—Ä–∞—Å–∏–≤—ã–π —Ñ–æ—Ä–º–∞—Ç
      formatDate(dateStr) {
        if (!dateStr) return '';
        const normalized = this.normalizeDate(dateStr);
        const [d, m, y] = normalized.split('.').map(Number);
        const months = [
          '—è–Ω–≤–∞—Ä—è', '—Ñ–µ–≤—Ä–∞–ª—è', '–º–∞—Ä—Ç–∞', '–∞–ø—Ä–µ–ª—è', '–º–∞—è', '–∏—é–Ω—è',
          '–∏—é–ª—è', '–∞–≤–≥—É—Å—Ç–∞', '—Å–µ–Ω—Ç—è–±—Ä—è', '–æ–∫—Ç—è–±—Ä—è', '–Ω–æ—è–±—Ä—è', '–¥–µ–∫–∞–±—Ä—è'
        ];
        return `${d} ${months[m - 1]} ${y}`;
      },

      getEventTypesForDay(day) {
        return day.events.map(event => event.type);
      },

      getEventTitleByType(type) {
        const map = {
          1: '–≠—Ñ–∏—Ä',
          2: '–†–æ–∑—ã–≥—Ä—ã—à',
          3: '–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ'
        };
        return map[type] || '–°–æ–±—ã—Ç–∏–µ';
      },

      getEventTitle(eventObj) {
        return eventObj.title || '–°–æ–±—ã—Ç–∏–µ';
      },

      getEventDescription(eventObj) {
        return '';
      },

      selectDay(day) {
        if (!day.hasEvents) return;
        this.selectedDate = day.date;
      },

      isSelected(dateStr) {
        if (!this.selectedDate || !dateStr) return false;
        return this.normalizeDate(this.selectedDate) === this.normalizeDate(dateStr);
      },

      parseDate(dateStr) {
        const normalized = this.normalizeDate(dateStr);
        const [d, m, y] = normalized.split('.').map(Number);
        const date = new Date(y, m - 1, d);

        if (isNaN(date.getTime())) {
          console.warn('Invalid date parsed:', dateStr);
          return new Date(0);
        }

        return date;
      },

      calculateDateBounds() {
        if (this.events.length === 0) {
          const now = new Date();
          this.minDate = this.maxDate = { year: now.getFullYear(), month: now.getMonth() };
          return;
        }

        const dates = this.events.map(e => this.parseDate(e.date));
        const minDate = new Date(Math.min(...dates));
        const maxDate = new Date(Math.max(...dates));

        this.minDate = { year: minDate.getFullYear(), month: minDate.getMonth() };
        this.maxDate = { year: maxDate.getFullYear(), month: maxDate.getMonth() };
      },

      setDefaultMonth() {
        const now = new Date();

        const futureEvents = this.events
          .map(e => ({ ...e, dateObj: this.parseDate(e.date) }))
          .filter(e => e.dateObj >= now)
          .sort((a, b) => a.dateObj - b.dateObj);

        if (futureEvents.length > 0) {
          const targetDate = futureEvents[0].dateObj;
          this.currentYear = targetDate.getFullYear();
          this.currentMonth = targetDate.getMonth();
          return;
        }

        const pastEvents = this.events
          .map(e => ({ ...e, dateObj: this.parseDate(e.date) }))
          .sort((a, b) => b.dateObj - a.dateObj);

        if (pastEvents.length > 0) {
          const targetDate = pastEvents[0].dateObj;
          this.currentYear = targetDate.getFullYear();
          this.currentMonth = targetDate.getMonth();
          return;
        }

        this.currentYear = now.getFullYear();
        this.currentMonth = now.getMonth();
      },

      setDefaultSelection() {
        const now = new Date();

        const futureEvents = this.events
          .filter(e => this.parseDate(e.date) >= now)
          .sort((a, b) => this.parseDate(a.date) - this.parseDate(b.date));

        if (futureEvents.length > 0) {
          this.selectedDate = futureEvents[0].date;
          return;
        }

        const pastEvents = this.events
          .filter(e => this.parseDate(e.date) < now)
          .sort((a, b) => this.parseDate(b.date) - this.parseDate(a.date));

        if (pastEvents.length > 0) {
          this.selectedDate = pastEvents[0].date;
          return;
        }

        this.selectedDate = null;
      },

      prevMonth() {
        if (!this.canGoPrev) return;

        if (this.currentMonth === 0) {
          this.currentMonth = 11;
          this.currentYear--;
        } else {
          this.currentMonth--;
        }
      },

      nextMonth() {
        if (!this.canGoNext) return;

        if (this.currentMonth === 11) {
          this.currentMonth = 0;
          this.currentYear++;
        } else {
          this.currentMonth++;
        }
      }
    },

    mounted() {
      this.parseEvents();
      this.calculateDateBounds();
      this.setDefaultMonth();
      this.setDefaultSelection();
    }
  });
}

---------------------------------
.calendar-grid {
  display: grid;
  grid-template-columns: repeat(7, 1fr);
  gap: 4px;
}

.calendar-day {
  padding: 10px;
  border: 1px solid #eee;
  cursor: pointer;
  text-align: center;
  position: relative;
}

.calendar-day.disabled {
  color: #ccc;
  cursor: not-allowed;
  background: #f9f9f9;
}

.calendar-day.selected {
  background: #e3f2fd;
  border-color: #2196f3;
}

.calendar-day.prev-month,
.calendar-day.next-month {
  color: #aaa;
  font-size: 0.9em;
}

.calendar-day.prev-month.disabled,
.calendar-day.next-month.disabled {
  background: #fafafa;
}

.event-icons {
  display: flex;
  gap: 2px;
  justify-content: center;
  margin-top: 4px;
}

.event-icon {
  display: inline-block;
  width: 12px;
  height: 12px;
  border-radius: 50%;
}

.icon-type-1 { background: #ff5722; } /* –≠—Ñ–∏—Ä */
.icon-type-2 { background: #4caf50; } /* –†–æ–∑—ã–≥—Ä—ã—à */
.icon-type-3 { background: #2196f3; } /* –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ */

.events-column {
  padding: 20px;
  border-left: 1px solid #eee;
  flex: 1;
}
