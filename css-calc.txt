receivedDateMobile([year, month]) {
  const dateString = `${year}-${month}`;
  this.$nextTick(() => {
    const container = this.$refs.mobileShedule;
    const element = container.querySelector(`[data-date="${dateString}"]`);
    
    if (element) {
      setTimeout(() => {
        this.scrollToElementSmoothly(container, element);
      }, 20);
    }
  });
},

methods: {
  // Функция для плавного скролла
  scrollSmoothly(element, targetPosition, duration = 300) {
    const startPosition = element.scrollTop;
    const distance = targetPosition - startPosition;
    const startTime = performance.now();

    function animateScroll(currentTime) {
      const timeElapsed = currentTime - startTime;
      const progress = Math.min(timeElapsed / duration, 1);
      const easeProgress = progress < 0.5 
        ? 2 * progress * progress 
        : 1 - Math.pow(-2 * progress + 2, 2) / 2; // Квадратичная easing-функция

      element.scrollTop = startPosition + (distance * easeProgress);
      
      if (timeElapsed < duration) {
        requestAnimationFrame(animateScroll);
      }
    }

    requestAnimationFrame(animateScroll);
  },

  // Основная функция для определения стратегии скролла
  scrollToElementSmoothly(container, element) {
    const containerRect = container.getBoundingClientRect();
    const elementRect = element.getBoundingClientRect();
    
    // Проверяем, помещается ли элемент полностью в видимой области контейнера
    const isFullyVisible = (
      elementRect.top >= containerRect.top && 
      elementRect.bottom <= containerRect.bottom
    );
    
    // Если элемент уже полностью виден, ничего не делаем
    if (isFullyVisible) return;
    
    // Вычисляем позицию элемента относительно контейнера
    const elementTopRelative = elementRect.top - containerRect.top;
    const elementBottomRelative = elementRect.bottom - containerRect.top;
    
    // Проверяем, есть ли скролл у контейнера
    const hasContainerScroll = container.scrollHeight > container.clientHeight;
    
    if (hasContainerScroll) {
      // Если элемент выше видимой области
      if (elementTopRelative < 0) {
        this.scrollSmoothly(container, container.scrollTop + elementTopRelative - 10);
      } 
      // Если элемент ниже видимой области
      else if (elementBottomRelative > container.clientHeight) {
        this.scrollSmoothly(
          container, 
          container.scrollTop + (elementBottomRelative - container.clientHeight) + 10
        );
      }
    } else {
      // Если скролла у контейнера нет, скроллим страницу
      const pageScrollTo = containerRect.top + window.pageYOffset - 50; // 50px отступ сверху
      
      // Плавный скролл страницы без использования behavior: 'smooth'
      const startPosition = window.pageYOffset;
      const distance = pageScrollTo - startPosition;
      const duration = 300;
      const startTime = performance.now();

      function animateScroll(currentTime) {
        const timeElapsed = currentTime - startTime;
        const progress = Math.min(timeElapsed / duration, 1);
        const easeProgress = progress < 0.5 
          ? 2 * progress * progress 
          : 1 - Math.pow(-2 * progress + 2, 2) / 2;

        window.scrollTo(0, startPosition + (distance * easeProgress));
        
        if (timeElapsed < duration) {
          requestAnimationFrame(animateScroll);
        }
      }

      requestAnimationFrame(animateScroll);
    }
  }
}
