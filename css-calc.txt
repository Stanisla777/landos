receivedDateMobile([year, month]) {
  const dateString = `${year}-${month}`;
  this.$nextTick(() => {
    const element = this.$refs.mobileShedule.querySelector(`[data-date="${dateString}"]`);
    if (element) {
      this.smoothScrollToElement(element);
    }
  });
},

async smoothScrollToElement(element) {
  const container = this.$refs.mobileShedule;
  
  // Сначала убедимся, что контейнер виден в viewport
  await this.scrollContainerIntoView(container);
  
  // Затем скроллим внутри контейнера
  await this.scrollToElementInContainer(container, element);
},

async scrollContainerIntoView(container) {
  const containerRect = container.getBoundingClientRect();
  const viewportHeight = window.innerHeight || document.documentElement.clientHeight;
  
  // Проверяем, полностью ли контейнер в viewport
  const buffer = 20; // Небольшой отступ
  const isFullyVisible = 
    containerRect.top >= buffer && 
    containerRect.bottom <= (viewportHeight - buffer);
  
  if (!isFullyVisible) {
    // Вычисляем позицию для скролла страницы
    let targetScroll;
    if (containerRect.top < buffer) {
      // Контейнер выше viewport - скроллим вверх
      targetScroll = window.scrollY + containerRect.top - buffer;
    } else {
      // Контейнер ниже viewport - скроллим вниз
      targetScroll = window.scrollY + containerRect.bottom - viewportHeight + buffer;
    }
    
    await this.animateScroll(window, targetScroll, 600);
  }
},

async scrollToElementInContainer(container, element) {
  const containerRect = container.getBoundingClientRect();
  const elementRect = element.getBoundingClientRect();
  
  // Вычисляем относительную позицию элемента внутри контейнера
  const relativeTop = elementRect.top - containerRect.top;
  const relativeBottom = elementRect.bottom - containerRect.top;
  
  const containerHeight = containerRect.height;
  const buffer = 20; // Небольшой отступ
  
  // Проверяем, виден ли элемент в контейнере
  const isElementVisible = 
    relativeTop >= buffer && 
    relativeBottom <= (containerHeight - buffer);
  
  if (!isElementVisible) {
    // Вычисляем целевую позицию скролла
    let targetScroll;
    if (relativeTop < buffer) {
      // Элемент выше видимой области - скроллим вверх
      targetScroll = container.scrollTop + relativeTop - buffer;
    } else {
      // Элемент ниже видимой области - скроллим вниз
      targetScroll = container.scrollTop + relativeBottom - containerHeight + buffer;
    }
    
    await this.animateScroll(container, targetScroll, 600);
  }
},

animateScroll(element, targetPosition, duration) {
  return new Promise(resolve => {
    const startPosition = element.scrollTop || window.scrollY;
    const distance = targetPosition - startPosition;
    let startTime = null;

    const animation = (timestamp) => {
      if (!startTime) startTime = timestamp;
      const progress = timestamp - startTime;
      const percentage = Math.min(progress / duration, 1);

      // Кубическая easing функция для плавности
      const easing = t => t<.5 ? 4*t*t*t : (t-1)*(2*t-2)*(2*t-2)+1;
      const scrollNow = startPosition + (distance * easing(percentage));

      if (element === window) {
        window.scrollTo(0, scrollNow);
      } else {
        element.scrollTop = scrollNow;
      }

      if (progress < duration) {
        window.requestAnimationFrame(animation);
      } else {
        resolve();
      }
    };

    window.requestAnimationFrame(animation);
  });
}
