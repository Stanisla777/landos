plugins: [
  store => {
    // Флаг для предотвращения рекурсивных обновлений
    let isUpdating = false;
    
    // Основной watch для критических параметров
    store.watch(
      state => ({
        loanAmount: state.loanAmount,
        annualInterestRate: state.annualInterestRate,
        loanTerm: state.loanTerm,
        startMortage: state.startMortage
      }),
      (newVal, oldVal) => {
        // Проверяем, что хотя бы одно значение изменилось
        if (!isUpdating && (
          newVal.loanAmount !== oldVal.loanAmount ||
          newVal.annualInterestRate !== oldVal.annualInterestRate ||
          newVal.loanTerm !== oldVal.loanTerm ||
          newVal.startMortage !== oldVal.startMortage
        )) {
          isUpdating = true;
          
          // Вызываем оба мутатора синхронно
          store.commit('mutationTotalCalculate');
          store.commit('mutationCollectAnswer');
          
          // Даём Vue время обновить DOM перед следующим циклом
          Vue.nextTick(() => {
            isUpdating = false;
          });
        }
      },
      { deep: true, immediate: false }
    );
    
    // Отдельные watch-еры для answers_to_send
    ['cost_property', 'initial_payment', 'annualInterestRate', 'loanTerm'].forEach(prop => {
      store.watch(
        state => state[prop],
        (newValue) => {
          if (!isUpdating) {
            const map = {
              'cost_property': 'loanAmount',
              'initial_payment': 'initialPayment',
              'annualInterestRate': 'bet',
              'loanTerm': 'loanTerm'
            };
            Vue.set(store.state.answers_to_send, map[prop], newValue);
          }
        },
        { deep: true }
      );
    });
  }
]

------------------------------------------

mutationTotalCalculate(state) {
  // Проверяем, что все необходимые параметры установлены и валидны
  if (!state.loanAmount || state.loanAmount <= 0 || 
      !state.annualInterestRate || state.annualInterestRate < 0 ||
      !state.loanTerm || state.loanTerm <= 0 ||
      !state.startMortage) {
    return;
  }

  // Вычисляем график платежей
  const newShedule = calculateMortgageSheduleFirst(
    state.loanAmount,
    state.annualInterestRate,
    state.loanTerm,
    state.startMortage,
    state.array_early_repayment
  );

  // Если график не изменился, не обновляем состояние
  if (JSON.stringify(newShedule) === JSON.stringify(state.shedule)) {
    return;
  }

  // Обновляем состояние одним атомарным действием
  state.shedule = newShedule;
  
  // Все последующие вычисления делаем только если есть график
  if (newShedule.length > 0) {
    state.amount_taxes_paid = payAllInterest(newShedule);
    state.debt_interest = state.amount_taxes_paid + state.loanAmount;
    
    // Вычисляем налоговые вычеты
    state.tax_deduction_property = Math.min(
      state.loanAmount * 0.13,
      state.transfer_parametr.max_tax_deduction_property
    );
    
    state.tax_deduction_interest = Math.min(
      state.amount_taxes_paid * 0.13,
      state.transfer_parametr.max_tax_deduction_interest
    );
    
    state.total_tax_deduction = state.tax_deduction_property + state.tax_deduction_interest;
    
    // Вычисляем необходимый доход
    if (newShedule[0] && newShedule[0].payment) {
      state.required_income = newShedule[0].payment / 0.5;
    }
  }
}

----------------------------------

mutationCollectAnswer(state) {
  const answers = {
    loanAmount: state.cost_property,
    initialPayment: state.initial_payment,
    bet: state.annualInterestRate,
    loanTerm: state.loanTerm
  };
  
  // Обновляем только если значения действительно изменились
  Object.keys(answers).forEach(key => {
    if (state.answers_to_send[key] !== answers[key]) {
      Vue.set(state.answers_to_send, key, answers[key]);
    }
  });
}
