scrollToElementSmart(container, targetElement) {
  const containerRect = container.getBoundingClientRect();
  const targetRect = targetElement.getBoundingClientRect();
  const pageScrollTop = window.scrollY;

  const targetTopInContainer = targetRect.top - containerRect.top + container.scrollTop;
  const maxContainerScroll = container.scrollHeight - container.clientHeight;

  // Желаемая позиция скролла контейнера, чтобы элемент был вверху
  const desiredContainerScroll = Math.max(0, Math.min(targetTopInContainer, maxContainerScroll));

  // Проверка: может ли контейнер проскроллиться до нужной позиции?
  const canScrollContainer = container.scrollHeight > container.clientHeight;

  if (canScrollContainer) {
    // Всегда пытаемся проскроллить контейнер, чтобы элемент был вверху
    this.smoothScrollTo(container, 'scrollTop', desiredContainerScroll, 300, (val) => {
      container.scrollTop = val;
    });

    // После анимации проверим, попал ли элемент в видимую область экрана
    setTimeout(() => {
      const finalTargetRect = targetElement.getBoundingClientRect();
      if (
        finalTargetRect.top < 0 ||
        finalTargetRect.bottom > window.innerHeight
      ) {
        // Элемент всё ещё частично или полностью вне экрана — подкручиваем страницу
        const newPageScrollTop = window.scrollY + finalTargetRect.top - 10;
        this.smoothScrollTo(window, 'scrollY', newPageScrollTop, 300, (val) => {
          window.scrollTo(0, val);
        });
      }
    }, 310);
  } else {
    // Контейнер не скроллится — скроллим страницу к контейнеру
    const pageTarget = pageScrollTop + containerRect.top - 10;
    this.smoothScrollTo(window, 'scrollY', pageTarget, 300, (val) => {
      window.scrollTo(0, val);
    });
  }
},
