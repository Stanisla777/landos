methods: {
  receivedDateMobile([year, month]) {
    const dateString = `${year}-${month}`;
    this.$nextTick(() => {
      const element = this.$refs.mobileShedule.querySelector(`[data-date="${dateString}"]`);
      
      if (element) {
        setTimeout(() => {
          this.scrollToElementSafely(element);
        }, 20);
      }
    });
  },
  
  scrollToElementSafely(element) {
    const container = this.$refs.mobileShedule;
    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) || 
                 (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
    
    // Проверяем, есть ли скролл у контейнера
    const hasContainerScroll = container.scrollHeight > container.clientHeight;
    
    // Получаем позиции элемента относительно контейнера и документа
    const containerRect = container.getBoundingClientRect();
    const elementRect = element.getBoundingClientRect();
    
    // Позиция элемента относительно контейнера
    const elementTopInContainer = elementRect.top - containerRect.top;
    const elementBottomInContainer = elementRect.bottom - containerRect.top;
    
    if (hasContainerScroll) {
      // Проверяем, виден ли элемент полностью в контейнере
      const isFullyVisible = elementTopInContainer >= 0 && 
                            elementBottomInContainer <= container.clientHeight;
      
      if (!isFullyVisible) {
        // Вычисляем позицию для скролла контейнера
        const targetScroll = elementTopInContainer - (container.clientHeight - element.clientHeight) / 2;
        
        // Ограничиваем максимальный скролл
        const maxScroll = container.scrollHeight - container.clientHeight;
        const finalScroll = Math.min(Math.max(0, targetScroll), maxScroll);
        
        // Для iOS используем обычный scrollTop, для других - smooth
        if (isIOS) {
          container.scrollTop = finalScroll;
        } else {
          container.scrollTo({
            top: finalScroll,
            behavior: 'smooth'
          });
        }
        
        // После скролла контейнера проверяем, нужно ли скроллить страницу
        this.$nextTick(() => {
          const newElementRect = element.getBoundingClientRect();
          const isElementInViewport = newElementRect.top >= 0 && 
                                    newElementRect.bottom <= window.innerHeight;
          
          if (!isElementInViewport) {
            this.scrollPageToElement(element, isIOS);
          }
        });
      }
    } else {
      // Если у контейнера нет скролла, скроллим страницу
      this.scrollPageToElement(element, isIOS);
    }
  },
  
  scrollPageToElement(element, isIOS) {
    const elementRect = element.getBoundingClientRect();
    const offset = window.pageYOffset;
    const targetPosition = offset + elementRect.top - (window.innerHeight - elementRect.height) / 2;
    
    if (isIOS) {
      // Для iOS используем кастомный плавный скролл
      this.smoothScrollTo(targetPosition);
    } else {
      // Для других браузеров - нативный smooth
      window.scrollTo({
        top: targetPosition,
        behavior: 'smooth'
      });
    }
  },
  
  smoothScrollTo(targetPosition) {
    const startPosition = window.pageYOffset;
    const distance = targetPosition - startPosition;
    if (distance === 0) return;
    
    const duration = 300;
    let startTime = null;
    
    const animation = (currentTime) => {
      if (!startTime) startTime = currentTime;
      const timeElapsed = currentTime - startTime;
      const run = this.easeInOutQuad(timeElapsed, startPosition, distance, duration);
      window.scrollTo(0, run);
      if (timeElapsed < duration) {
        requestAnimationFrame(animation);
      }
    };
    
    requestAnimationFrame(animation);
  },
  
  easeInOutQuad(t, b, c, d) {
    t /= d / 2;
    if (t < 1) return c / 2 * t * t + b;
    t--;
    return -c / 2 * (t * (t - 2) - 1) + b;
  },
  
  handleScroll(event) {
    // Предотвращаем скролл страницы, если скроллится контейнер
    if (event.target === this.$refs.mobileShedule) {
      event.stopPropagation();
    }
  }
}
