initRealtySlider() {
  // Ползунок работает с целыми числами от 0 до 100
  this.realtySlider = noUiSlider.create(this.$refs.mortgagePrice, {
    start: [Math.floor(this.start)], // например, 6
    connect: [true, false],
    step: 1,
    range: {
      'min': [Math.floor(this.stgMin)], // 0.1 → 0
      'max': [Math.floor(this.stgMax)]  // 100
    }
  });

  this.realtySlider.on('slide', (values) => {
    if (this.isUpdating) return;
    this.isUpdating = true;

    const integerValue = parseFloat(values[0]); // 6, 7, 8...
    // Восстанавливаем дробную часть, если она была
    const finalValue = this.decimalPart !== null ? integerValue + this.decimalPart : integerValue;

    // Но не позволяем уйти ниже stgMin
    const clampedValue = Math.max(finalValue, this.stgMin);

    this.updateInputValue(clampedValue);
    this.updateStoreValue(clampedValue);

    this.isUpdating = false;
  });
},

this.mask_interest.on('accept', () => {
  if (this.isUpdating || !this.mask_interest.typedValue) return;
  this.isUpdating = true;

  let value = parseFloat(this.mask_interest.unmaskedValue.replace(',', '.'));
  if (isNaN(value)) value = this.stgMin;

  // Обязательно ограничиваем по min/max
  if (value < this.stgMin) value = this.stgMin;
  if (value > this.stgMax) value = this.stgMax;

  // Сохраняем дробную часть
  this.decimalPart = value % 1 || null; // если 0.00 — null

  // Ползунок двигается по целой части, но не ниже 0
  const sliderValue = Math.floor(value);

  this.updateSliderValue(sliderValue);
  this.updateInputValue(value); // важно: обновляем с дробной частью
  this.updateStoreValue(value);

  this.isUpdating = false;
});

updateInputValue(value) {
  const formattedValue = value.toString().replace('.', ',');
  this.dataField = formattedValue;
  this.dataFieldForCalculation = value;

  if (this.mask_interest) {
    this.mask_interest.unmaskedValue = value.toString();
  } else {
    this.$refs.realtyInput.value = formattedValue;
  }
},

inputBlur(el) {
  const element = el.currentTarget;
  element.closest('.js--tex-deduc-input').classList.remove('input-focus');

  let value = parseFloat(this.mask_interest.unmaskedValue.replace(',', '.'));

  if (isNaN(value) || !value) {
    value = this.stgMin;
  }

  if (value < this.stgMin) value = this.stgMin;
  if (value > this.stgMax) value = this.stgMax;

  this.decimalPart = value % 1 || null;
  this.updateSliderValue(Math.floor(value));
  this.updateInputValue(value);
  this.updateStoreValue(value);
}

mounted() {
  this.initRealtySlider();
  this.initInputMask();

  let initialValue = this.start;

  if (this.answers && this.answers.bet) {
    const betValue = parseFloat(this.answers.bet);
    if (!isNaN(betValue)) {
      initialValue = betValue;
    }
  }

  // Установка начального значения
  this.decimalPart = (initialValue % 1) || null;
  this.updateSliderValue(Math.floor(initialValue));
  this.updateInputValue(initialValue);
  this.updateStoreValue(initialValue);
}

data() {
  return {
    stgMin: 0.1,
    stgMax: 100,
    start: 6.0,
    decimalPart: null,
    // ...
  }
}

range: {
  'min': [Math.floor(this.stgMin)], // 0
  'max': [Math.floor(this.stgMax)]  // 100
}
