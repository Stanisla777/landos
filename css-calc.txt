receivedDateMobile([year, month]) {
  const dateString = `${year}-${month}`;
  this.$nextTick(() => {
    const targetElement = this.$refs.mobileShedule.querySelector(`[data-date="${dateString}"]`);
    if (!targetElement) return;

    // Находим первый прокручиваемый родительский элемент
    let scrollContainer = targetElement;
    while (scrollContainer && scrollContainer !== document.body) {
      const style = window.getComputedStyle(scrollContainer);
      if (style.overflowY === 'auto' || style.overflowY === 'scroll') {
        break;
      }
      scrollContainer = scrollContainer.parentNode;
    }

    // Если не нашли контейнер со скроллом, используем window
    if (!scrollContainer || scrollContainer === document.body) {
      scrollContainer = window;
    }

    const isWindow = scrollContainer === window;
    const startPosition = isWindow 
      ? window.pageYOffset 
      : scrollContainer.scrollTop;
    
    const targetRect = targetElement.getBoundingClientRect();
    const containerRect = isWindow 
      ? { top: 0 } 
      : scrollContainer.getBoundingClientRect();
    
    const targetPosition = isWindow
      ? targetRect.top + window.pageYOffset
      : targetRect.top - containerRect.top + scrollContainer.scrollTop;

    const distance = targetPosition - startPosition - 10; // 10px отступ сверху
    const duration = 800;
    let startTime = null;

    function animation(currentTime) {
      if (startTime === null) startTime = currentTime;
      const timeElapsed = currentTime - startTime;
      const progress = Math.min(timeElapsed / duration, 1);
      const ease = easeInOutQuad(progress);

      if (isWindow) {
        window.scrollTo(0, startPosition + distance * ease);
      } else {
        scrollContainer.scrollTop = startPosition + distance * ease;
      }

      if (timeElapsed < duration) {
        requestAnimationFrame(animation);
      }
    }

    function easeInOutQuad(t) {
      return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
    }

    requestAnimationFrame(animation);
  });
}
