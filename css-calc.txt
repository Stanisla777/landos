methods: {
  receivedDateMobile([year, month]) {
    const dateString = `${year}-${month}`;
    this.$nextTick(() => {
      const element = this.$refs.mobileShedule.querySelector(`[data-date="${dateString}"]`);
      
      if (element) {
        setTimeout(() => {
          this.scrollToElement(element);
        }, 20);
      }
    });
  },
  
  scrollToElement(element) {
    const container = this.$refs.mobileShedule;
    const containerRect = container.getBoundingClientRect();
    const elementRect = element.getBoundingClientRect();
    
    // Проверяем, есть ли скролл у контейнера
    const hasContainerScroll = container.scrollHeight > container.clientHeight;
    
    if (hasContainerScroll) {
      // Проверяем, полностью ли элемент виден в контейнере
      const isFullyVisible = (
        elementRect.top >= containerRect.top && 
        elementRect.bottom <= containerRect.bottom
      );
      
      if (!isFullyVisible) {
        // Вычисляем позицию для скролла контейнера
        const containerScrollTop = container.scrollTop;
        const elementOffsetTop = element.offsetTop - container.offsetTop;
        const elementHeight = element.offsetHeight;
        const containerHeight = container.clientHeight;
        
        // Позиционируем элемент по центру контейнера
        let scrollTo = elementOffsetTop - (containerHeight - elementHeight) / 2;
        
        // Ограничиваем скролл границами контейнера
        scrollTo = Math.max(0, Math.min(scrollTo, container.scrollHeight - containerHeight));
        
        // Применяем скролл
        container.scrollTop = scrollTo;
        
        // После скролла контейнера проверяем, нужно ли скроллить страницу
        this.$nextTick(() => {
          const newElementRect = element.getBoundingClientRect();
          const viewportHeight = window.innerHeight;
          
          // Если нижняя часть элемента все еще ниже viewport (с учетом отступа)
          if (newElementRect.bottom > viewportHeight - 20) {
            const pageScrollTo = window.pageYOffset + newElementRect.top - (viewportHeight - newElementRect.height) / 2;
            this.smoothScrollTo(pageScrollTo);
          }
        });
      }
    } else {
      // Если скролла у контейнера нет, скроллим страницу
      const pageScrollTo = window.pageYOffset + elementRect.top - (window.innerHeight - elementRect.height) / 2;
      this.smoothScrollTo(pageScrollTo);
    }
  },
  
  smoothScrollTo(targetPosition) {
    const startPosition = window.pageYOffset;
    const distance = targetPosition - startPosition;
    
    // Не скроллим если расстояние меньше 1px
    if (Math.abs(distance) < 1) return;
    
    const duration = Math.min(500, Math.abs(distance) * 0.5);
    let startTime = null;
    
    const animation = (currentTime) => {
      if (!startTime) startTime = currentTime;
      const timeElapsed = currentTime - startTime;
      const run = this.easeInOutQuad(timeElapsed, startPosition, distance, duration);
      window.scrollTo(0, run);
      if (timeElapsed < duration) {
        requestAnimationFrame(animation);
      }
    };
    
    requestAnimationFrame(animation);
  },
  
  easeInOutQuad(t, b, c, d) {
    t /= d / 2;
    if (t < 1) return c / 2 * t * t + b;
    t--;
    return -c / 2 * (t * (t - 2) - 1) + b;
  },
  
  handleScroll(event) {
    // Предотвращаем скролл страницы, если скроллится контейнер
    if (event.target === this.$refs.mobileShedule) {
      event.stopPropagation();
    }
  }
}
