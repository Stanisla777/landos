totalCalc(parent){
  const array_input = document.querySelectorAll('.js--wr-col-input.active');
  let result = 0; // Остальные вычеты (не соц., не инвестиционные)
  let result_soc = 0; // Сумма всех социальных вычетов (до применения лимита!)
  let result_contributions = 0; // Сумма всех инвестиционных вычетов (до применения лимита!)

  // ШАГ 1: Пройти по всем активным полям и собрать сырые значения (без лимитов!)
  for (let item of array_input) {
    if (!item.classList.contains('js-wr-col-input-soc') && item.querySelector('.js--result-calc') && !item.classList.contains('js--wr-col-input-contributions')) {
      // Собираем сумму для обычных вычетов
      const val = parseInt(item.querySelector('.js--result-calc').textContent.replace(/\s/g, ''));
      result += isNaN(val) ? 0 : val;
    }
    else if (item.classList.contains('js-wr-col-input-soc') && item.querySelector('.js--result-calc')) {
      // Собираем сумму для всех социальных вычетов (включая дорогостоящее лечение)
      const val = parseInt(item.querySelector('.js--result-calc').textContent.replace(/\s/g, ''));
      result_soc += isNaN(val) ? 0 : val;
    }
    else if (item.classList.contains('js--wr-col-input-contributions') && item.querySelector('.js--result-calc')) {
      // Собираем сумму для инвестиционных вычетов
      const val = parseInt(item.querySelector('.js--result-calc').textContent.replace(/\s/g, ''));
      result_contributions += isNaN(val) ? 0 : val;
    }
  }

  // ШАГ 2: ПРИМЕНЯЕМ ЛИМИТЫ ТОЛЬКО К ИТОГОВЫМ СУММАМ (ЗДЕСЬ ИСПРАВЛЕНИЕ!)
  // Социальные вычеты
  if (this.selected_year <= 2023 && result_soc > this.limit_2023) {
    result_soc = this.limit_2023;
  }
  if (this.selected_year >= 2024 && result_soc > this.limit_2024) {
    result_soc = this.limit_2024;
  }

  // Инвестиционные вычеты
  if (result_contributions > 52000) {
    result_contributions = 52000;
  }

  // ШАГ 3: ПРОВЕРКА НА NaN И ОБНОВЛЕНИЕ ИТОГОВОЙ СУММЫ (СОХРАНЯЕМ ОРИГИНАЛЬНУЮ ЛОГИКУ!)
  // Теперь мы знаем, что result, result_soc, result_contributions - это числа (или 0),
  // поэтому проверка isNaN уже не нужна внутри цикла, но мы сохраняем её структуру,
  // чтобы не сломать возможные зависимости в других местах.
  if (!isNaN(result) && !isNaN(result_soc) && !isNaN(result_contributions)) {
    this.total_calculate = (result + result_soc + result_contributions).toFixed(0).toString().replace(/(\d)(?=(\d{3})+$)/g, '$1 ');
  } else {
    // На всякий случай, если вдруг где-то всё же остался NaN (хотя теоретически быть не должно),
    // можно установить 0, но обычно этого не происходит благодаря шагу 1.
    this.total_calculate = 0;
  }

  // Обработка случая, когда нет ни одного активного поля
  if (array_input.length === 0) {
    this.total_calculate = 0;
  }

  this.errorMessage();
},
