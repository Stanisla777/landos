async receivedDateMobile([year, month]) {
  const dateString = `${year}-${month}`;
  await this.$nextTick();
  
  const element = this.$refs.mobileShedule.querySelector(`[data-date="${dateString}"]`);
  if (!element) return;

  const container = this.$refs.mobileShedule;
  const containerRect = container.getBoundingClientRect();
  const elementRect = element.getBoundingClientRect();

  // Проверяем, виден ли элемент в контейнере
  const isElementInContainer = (
    elementRect.top >= containerRect.top &&
    elementRect.bottom <= containerRect.bottom
  );

  // Проверяем, виден ли контейнер в viewport
  const isContainerInView = (
    containerRect.top >= 0 &&
    containerRect.bottom <= window.innerHeight
  );

  // Если контейнер не полностью в viewport, сначала скроллим страницу к контейнеру
  if (!isContainerInView) {
    await this.smoothScrollTo(container);
  }

  // Если элемент не виден в контейнере, скроллим контейнер к элементу
  if (!isElementInContainer) {
    await this.smoothScrollInside(container, element);
  }
},

// Плавный скролл страницы к элементу
smoothScrollTo(element) {
  return new Promise(resolve => {
    element.scrollIntoView({
      behavior: 'smooth',
      block: 'nearest'
    });
    
    // Ждём завершения скролла
    setTimeout(resolve, 1000);
  });
},

// Плавный скролл внутри контейнера
smoothScrollInside(container, element) {
  return new Promise(resolve => {
    // Вычисляем позицию элемента относительно контейнера
    const scrollPosition = element.offsetTop - container.offsetTop;
    
    // Плавный скролл с помощью CSS transitions
    container.style.scrollBehavior = 'smooth';
    container.scrollTop = scrollPosition;
    
    // Возвращаем стандартное поведение после скролла
    setTimeout(() => {
      container.style.scrollBehavior = 'auto';
      resolve();
    }, 1000);
  });
}

scroll-behavior: smooth;
  transition: scroll-behavior 0.3s ease;
