receivedDateMobile([year, month]) {
  const dateString = `${year}-${month}`;
  this.$nextTick(() => {
    const container = this.$refs.mobileShedule; // блок с max-height и overflow
    const element = container.querySelector(`[data-date="${dateString}"]`);

    if (!element || !container) return;

    this.scrollToElementSmoothly(container, element);
  });
},

methods: {
  scrollToElementSmoothly(container, targetElement) {
    const containerRect = container.getBoundingClientRect();
    const targetRect = targetElement.getBoundingClientRect();
    const pageRect = document.documentElement.getBoundingClientRect();

    const containerScrollTop = container.scrollTop;
    const targetTopRelative = targetRect.top - containerRect.top; // позиция элемента относительно контейнера
    const containerVisibleHeight = containerRect.height;

    // Сколько нужно проскроллить внутри контейнера, чтобы элемент был сверху
    const neededScrollTop = targetTopRelative;

    // Проверим, можем ли мы проскроллить внутри контейнера
    const maxScroll = container.scrollHeight - container.clientHeight;

    if (neededScrollTop <= container.scrollTop + 5 && neededScrollTop >= container.scrollTop - 5) {
      // Уже в зоне видимости, ничего не делаем
      return;
    }

    // === Случай 1: можно проскроллить внутри контейнера ===
    if (neededScrollTop >= 0 && neededScrollTop <= maxScroll) {
      this.smoothScrollTo(container, 'scrollTop', neededScrollTop, 300, (value) => {
        container.scrollTop = value;
      });
    }
    // === Случай 2: элемент выше контейнера или не влезает в контейнер после скролла ===
    else {
      // Нужно проскроллить всю страницу так, чтобы контейнер оказался сверху
      const pageScrollTarget = pageRect.top + containerRect.top - 10; // с небольшим отступом

      this.smoothScrollTo(window, 'scrollY', pageScrollTarget, 300, (value) => {
        window.scrollTo(0, value);
      });
    }
  },

  smoothScrollTo(element, property, target, duration, setValue) {
    const start = element[property];
    const change = target - start;
    let startTime = null;

    const animateScroll = (currentTime) => {
      if (startTime === null) startTime = currentTime;
      const timeElapsed = currentTime - startTime;
      const progress = Math.min(timeElapsed / duration, 1);

      // easeInOutCubic
      const ease = progress < 0.5
        ? 4 * progress * progress * progress
        : (progress - 1) * (2 * progress - 2) * (2 * progress - 2) + 1;

      const val = start + change * ease;
      setValue(val);

      if (timeElapsed < duration) {
        requestAnimationFrame(animateScroll);
      }
    };

    requestAnimationFrame(animateScroll);
  }
}
