/**
 * Плавный скролл к элементу с поддержкой всех браузеров и overflow-контейнеров
 * @param {HTMLElement|string} target - Элемент или селектор элемента
 * @param {object} [options] - Настройки
 * @param {number} [options.offset=0] - Дополнительный отступ
 * @param {number} [options.duration=600] - Длительность анимации (мс)
 * @param {string} [options.easing='easeInOutQuad'] - Функция плавности
 */
function smoothScrollTo(target, options = {}) {
  // Параметры по умолчанию
  const {
    offset = 0,
    duration = 600,
    easing = 'easeInOutQuad'
  } = options;

  // Поддерживаемые функции плавности
  const easingFunctions = {
    easeInOutQuad(t) {
      return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
    },
    easeInCubic(t) {
      return t * t * t;
    },
    easeOutCubic(t) {
      return (--t) * t * t + 1;
    }
  };

  // Получаем элемент
  const element = typeof target === 'string' 
    ? document.querySelector(target) 
    : target;
  
  if (!element) return;

  // Находим ближайший scrollable-родитель
  const findScrollableParent = (el) => {
    if (!el) return document.documentElement;
    
    let parent = el.parentElement;
    while (parent) {
      const style = window.getComputedStyle(parent);
      if (style.overflowY === 'auto' || style.overflowY === 'scroll') {
        // Проверяем, что элемент действительно может скроллиться
        if (parent.scrollHeight > parent.clientHeight) {
          return parent;
        }
      }
      parent = parent.parentElement;
    }
    return document.documentElement;
  };

  const scrollContainer = findScrollableParent(element);
  const isBody = scrollContainer === document.documentElement;

  // Вычисляем позицию элемента относительно контейнера
  const containerRect = scrollContainer.getBoundingClientRect();
  const elementRect = element.getBoundingClientRect();
  
  let targetPosition = (isBody 
    ? window.pageYOffset + elementRect.top
    : scrollContainer.scrollTop + elementRect.top - containerRect.top) + offset;

  // Ограничиваем максимальную позицию скролла
  const maxScroll = isBody
    ? document.documentElement.scrollHeight - window.innerHeight
    : scrollContainer.scrollHeight - scrollContainer.clientHeight;
  
  targetPosition = Math.min(targetPosition, maxScroll);

  const startPosition = isBody ? window.pageYOffset : scrollContainer.scrollTop;
  const distance = targetPosition - startPosition;
  let startTime = null;

  // Функция анимации
  const animateScroll = (timestamp) => {
    if (!startTime) startTime = timestamp;
    const elapsed = timestamp - startTime;
    const progress = Math.min(elapsed / duration, 1);
    const easeProgress = easingFunctions[easing](progress);
    
    const scrollTo = startPosition + distance * easeProgress;
    
    if (isBody) {
      window.scrollTo(0, scrollTo);
    } else {
      scrollContainer.scrollTop = scrollTo;
    }
    
    if (elapsed < duration) {
      window.requestAnimationFrame(animateScroll);
    }
  };

  // Запускаем анимацию
  window.requestAnimationFrame(animateScroll);
}

// Полифил для requestAnimationFrame
(function() {
  const vendors = ['ms', 'moz', 'webkit', 'o'];
  for (let i = 0; i < vendors.length && !window.requestAnimationFrame; ++i) {
    window.requestAnimationFrame = window[`${vendors[i]}RequestAnimationFrame`];
    window.cancelAnimationFrame = window[`${vendors[i]}CancelAnimationFrame`] || 
                                 window[`${vendors[i]}CancelRequestAnimationFrame`];
  }

  if (!window.requestAnimationFrame) {
    let lastTime = 0;
    window.requestAnimationFrame = function(callback) {
      const currTime = new Date().getTime();
      const timeToCall = Math.max(0, 16 - (currTime - lastTime));
      const id = window.setTimeout(() => {
        callback(currTime + timeToCall);
      }, timeToCall);
      lastTime = currTime + timeToCall;
      return id;
    };
  }

  if (!window.cancelAnimationFrame) {
    window.cancelAnimationFrame = function(id) {
      clearTimeout(id);
    };
  }
}());

------------------------------------------------------------

smoothScrollTo('#myElement', {
  offset: -20,    // Отступ от элемента
  duration: 1000,  // Длительность анимации
  easing: 'easeOutCubic' // Тип анимации
});
