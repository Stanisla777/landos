export default {
  name: 'v-interest-rate',
  mixins: [numberFormatting],
  data() {
    return {
      realtySlider: null,
      dataField: '6,00',
      dataFieldForCalculation: 6.0,
      stgMin: 0.1,
      stgMiddle: 50,
      stgMax: 100,
      start: 6.0,
      input_salary: false,
      slider: false,
      mask_interest: null,
      isUpdating: false,
      lastSliderValue: 6.0,
      wasInteger: false // Флаг для отслеживания целых чисел при движении ползунка


------

methods: {
    formatValue(value) {
      // Форматируем с двумя знаками после запятой
      return parseFloat(value).toFixed(2).toString().replace('.', ',')
    },

    initRealtySlider() {
      this.realtySlider = noUiSlider.create(this.$refs.mortgagePrice, {
        start: [this.start],
        connect: 'lower',
        step: 1, // Шаг только для целых чисел
        range: {
          min: this.stgMin,
          max: this.stgMax
        },
      })

      this.realtySlider.on('start', (values) => {
        this.input_salary = false
        const currentValue = parseFloat(values[0])
        // Проверяем, было ли значение целым числом (например, 6.00)
        this.wasInteger = currentValue % 1 === 0
      });

      this.realtySlider.on('slide', (values, handle) => {
        if (this.isUpdating) return
        this.isUpdating = true

        let value = parseFloat(values[handle])
        
        // Если предыдущее значение было целым (например, 6.00), сохраняем .00 при движении
        if (this.wasInteger) {
          value = Math.round(value) // Округляем до целого
        } else {
          // Иначе сохраняем сотые из предыдущего значения
          const previousValue = this.dataFieldForCalculation
          const decimalPart = previousValue % 1
          value = Math.round(value) + decimalPart
        }
        
        // Гарантируем минимальное значение 0.1
        if (value < this.stgMin) value = this.stgMin
        
        this.updateInputValue(value)
        this.lastSliderValue = value

        this.isUpdating = false
      });

      this.realtySlider.on('set', (values, handle) => {
        if (this.isUpdating) return
        this.isUpdating = true

        let value = parseFloat(values[handle])
        
        // Аналогичная логика для финального установления значения
        if (this.wasInteger) {
          value = Math.round(value)
        } else {
          const previousValue = this.dataFieldForCalculation
          const decimalPart = previousValue % 1
          value = Math.round(value) + decimalPart
        }
        
        if (value < this.stgMin) value = this.stgMin
        
        this.updateInputValue(value)
        this.updateStoreValue(value)
        this.lastSliderValue = value

        this.isUpdating = false
      });
    },

    initInputMask() {
      const maskOptions = {
        mask: Number,
        scale: 2, // Разрешаем две цифры после запятой
        thousandsSeparator: '',
        padFractionalZeros: true,
        normalizeZeros: true,
        radix: ',',
        mapToRadix: ['.', ','],
        min: this.stgMin,
        max: this.stgMax,
        autofix: true,
        prepare: (value) => value.replace(/[бю\/]/gi, ',')
      };

      this.mask_interest = new IMask(this.$refs.realtyInput, maskOptions)
      this.mask_interest.value = this.formatValue(this.start)

      this.mask_interest.on('accept', () => {
        if (this.isUpdating || !this.mask_interest.typedValue) return
        this.isUpdating = true

        let value = parseFloat(this.mask_interest.unmaskedValue)
        if (isNaN(value)) value = this.stgMin

        // Корректируем значение, если оно выходит за границы
        if (value < this.stgMin) value = this.stgMin
        if (value > this.stgMax) value = this.stgMax

        // При ручном вводе сохраняем точное значение
        this.updateSliderValue(Math.floor(value)) // Ползунок устанавливаем на целую часть
        this.updateStoreValue(value)
        this.lastSliderValue = value
        this.wasInteger = value % 1 === 0

        this.isUpdating = false
      });
    },

    updateInputValue(value) {
      const formattedValue = this.formatValue(value)
      this.dataField = formattedValue
      this.dataFieldForCalculation = value

      if (this.mask_interest) {
        this.mask_interest.unmaskedValue = value.toString()
      } else {
        this.$refs.realtyInput.value = formattedValue
      }
    },

    updateSliderValue(value) {
      if (this.realtySlider) {
        this.realtySlider.set(Math.floor(value)) // Устанавливаем только целую часть
      }
    },

    updateStoreValue(value) {
      Storage.dispatch('ActionInterestRate', value)
    },

    inputFocus(el) {
      const element = el.currentTarget
      element.querySelector('input').focus()
    },

    keyUp(e) {
      if (e.key === 'Enter') {
        this.$refs.realtyInput.blur()
      }
    },

    inpRemoveMark(el) {
      const element = el.currentTarget;
      if (element.value === '0' || element.value === '0 %') {
        element.value = ''
      }
    },

    inputBlur(el) {
      const element = el.currentTarget;
      element.closest('.js--tex-deduc-input').classList.remove('input-focus')

      if (!element.value || element.value === '') {
        this.updateSliderValue(this.stgMin)
        this.updateInputValue(this.stgMin)
        this.updateStoreValue(this.stgMin)
        this.lastSliderValue = this.stgMin
        this.wasInteger = false
      }
    },
  },

  beforeDestroy() {
    if (this.mask_interest) {
      this.mask_interest.destroy()
    }
    if (this.realtySlider) {
      this.realtySlider.destroy()
    }
  },

  mounted() {
    this.initRealtySlider()
    this.initInputMask()
    this.updateStoreValue(this.start)
    this.lastSliderValue = this.start
    this.wasInteger = this.start % 1 === 0

    if (this.answers && this.answers.bet) {
      const initialValue = parseFloat(this.answers.bet)
      this.updateSliderValue(initialValue)
      this.updateInputValue(initialValue)
      this.updateStoreValue(initialValue)
      this.lastSliderValue = initialValue
      this.wasInteger = initialValue % 1 === 0
    }
  },
