methods: {
  receivedDateMobile([year, month]) {
    const dateString = `${year}-${month}`;
    this.$nextTick(() => {
      const element = this.$refs.mobileShedule.querySelector(`[data-date="${dateString}"]`);
      
      if (element) {
        setTimeout(() => {
          this.scrollToElement(element);
        }, 20);
      }
    });
  },
  
  scrollToElement(element) {
    const container = this.$refs.mobileShedule;
    const containerRect = container.getBoundingClientRect();
    const elementRect = element.getBoundingClientRect();
    
    // Проверяем, есть ли скролл у контейнера
    const hasContainerScroll = container.scrollHeight > container.clientHeight;
    
    // Вычисляем видимость элемента в контейнере
    const isElementFullyVisible = (
      elementRect.top >= containerRect.top && 
      elementRect.bottom <= containerRect.bottom
    );
    
    if (hasContainerScroll) {
      // Если элемент не полностью виден в контейнере
      if (!isElementFullyVisible) {
        // Вычисляем позицию для скролла контейнера
        const elementMiddle = elementRect.top + elementRect.height/2;
        const containerMiddle = containerRect.top + container.clientHeight/2;
        const scrollAmount = elementMiddle - containerMiddle;
        
        // Плавный скролл контейнера
        this.smoothScroll(container, container.scrollTop + scrollAmount);
      }
    } else {
      // Если скролла у контейнера нет, скроллим страницу
      const elementTopRelativeToViewport = elementRect.top;
      const targetScroll = window.pageYOffset + elementTopRelativeToViewport - (window.innerHeight / 3);
      
      // Плавный скролл страницы
      this.smoothScroll(window, targetScroll);
    }
  },
  
  smoothScroll(scrollable, targetPosition) {
    const isWindow = scrollable === window;
    const currentPosition = isWindow ? window.pageYOffset : scrollable.scrollTop;
    const distance = targetPosition - currentPosition;
    const duration = 300;
    let startTime = null;
    
    const animation = (currentTime) => {
      if (!startTime) startTime = currentTime;
      const timeElapsed = currentTime - startTime;
      const progress = Math.min(timeElapsed / duration, 1);
      const easeProgress = this.easeInOutQuad(progress);
      const newPosition = currentPosition + distance * easeProgress;
      
      if (isWindow) {
        window.scrollTo(0, newPosition);
      } else {
        scrollable.scrollTop = newPosition;
      }
      
      if (timeElapsed < duration) {
        requestAnimationFrame(animation);
      }
    };
    
    requestAnimationFrame(animation);
  },
  
  easeInOutQuad(progress) {
    return progress < 0.5 
      ? 2 * progress * progress 
      : -1 + (4 - 2 * progress) * progress;
  },
  
  handleScroll(event) {
    // Предотвращаем скролл страницы, если скроллится контейнер
    if (event.target === this.$refs.mobileShedule) {
      event.stopPropagation();
    }
  }
}
