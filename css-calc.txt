receivedDateMobile([year, month]) {
  const dateString = `${year}-${month}`;
  this.$nextTick(() => {
    const container = this.$refs.mobileShedule;
    const element = container?.querySelector(`[data-date="${dateString}"]`);

    if (!element || !container) return;

    this.scrollToElementSmoothly(container, element);
  });
},

methods: {
  scrollToElementSmoothly(container, targetElement) {
    const containerRect = container.getBoundingClientRect();
    const targetRect = targetElement.getBoundingClientRect();
    const pageRect = document.documentElement.getBoundingClientRect();

    const containerScrollTop = container.scrollTop;
    const containerHeight = container.clientHeight;
    const containerScrollHeight = container.scrollHeight;

    const targetTopInContainer = targetElement.offsetTop;
    const targetBottomInContainer = targetTopInContainer + targetRect.height;

    const maxContainerScroll = containerScrollHeight - containerHeight;

    // === 1. Проверим: элемент уже в зоне видимости контейнера (с небольшим запасом)?
    const currentVisibleTop = containerScrollTop;
    const currentVisibleBottom = containerScrollTop + containerHeight;

    const margin = 2; // небольшой запас, чтобы не дергать скролл при почти правильной позиции
    if (
      targetTopInContainer >= currentVisibleTop - margin &&
      targetBottomInContainer <= currentVisibleBottom + margin
    ) {
      // Элемент уже в зоне видимости — ничего не делаем
      return;
    }

    // === 2. Попробуем проскроллить ВНУТРИ контейнера
    // Нам нужно, чтобы элемент оказался вверху контейнера
    const desiredScrollTop = targetTopInContainer;

    if (desiredScrollTop <= maxContainerScroll && desiredScrollTop >= 0) {
      // Внутри контейнера можно проскроллить
      this.smoothScrollTo(container, 'scrollTop', desiredScrollTop, 300, (value) => {
        container.scrollTop = value;
      });
      return;
    }

    // === 3. Если элемент ВЫШЕ контейнера или НИЖЕ, но контейнер уже в конце
    // Тогда скроллим ВСЮ СТРАНИЦУ так, чтобы контейнер встал вверху экрана
    const targetPageScroll = pageRect.top + containerRect.top - 10; // с небольшим отступом сверху

    this.smoothScrollTo(window, 'scrollY', targetPageScroll, 300, (value) => {
      window.scrollTo(0, value);
    });
  },

  smoothScrollTo(element, property, target, duration, setValue) {
    const start = element === window ? window.pageYOffset : element[property];
    const change = target - start;
    let startTime = null;

    const animateScroll = (currentTime) => {
      if (startTime === null) startTime = currentTime;
      const timeElapsed = currentTime - startTime;
      const progress = Math.min(timeElapsed / duration, 1);

      // easeInOutCubic
      const ease = progress < 0.5
        ? 4 * progress * progress * progress
        : (progress - 1) * (2 * progress - 2) * (2 * progress - 2) + 1;

      const val = start + change * ease;
      setValue(val);

      if (timeElapsed < duration) {
        requestAnimationFrame(animateScroll);
      }
    };

    requestAnimationFrame(animateScroll);
  }
}
