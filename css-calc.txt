/* eslint-disable */
const path = require('path');
const fs = require('fs');
const { CleanWebpackPlugin } = require('clean-webpack-plugin');
const CopyWebpackPlugin = require('copy-webpack-plugin');
const HtmlWebpackPlugin = require('html-webpack-plugin');
const MiniCssExtractPlugin = require('mini-css-extract-plugin');
const TerserPlugin = require('terser-webpack-plugin');
const VueLoaderPlugin = require('vue-loader/lib/plugin');

function generateHtmlPlugins(templateDir) {
  const templateFiles = fs.readdirSync(path.resolve(__dirname, templateDir));
  return templateFiles.map((item) => {
    const parts = item.split('.');
    const name = parts[0];
    const extension = parts[1];
    return new HtmlWebpackPlugin({
      filename: `${name}.html`,
      template: path.resolve(__dirname, `${templateDir}/${name}.${extension}`),
      inject: false // ← вы всегда используете ручное подключение
    });
  });
}

module.exports = (env, argv) => {
  const isDev = argv.mode === 'development';
  const isProd = argv.mode === 'production';

  const config = {
    // ===== ENTRY =====
    entry: isDev
      ? ['./src/js/index.js', './src/scss/style.scss']
      : {
          all: ['./src/js/index.js'],
          'general-style': ['./src/scss/general-style.scss'],
          instruction: ['./src/scss/instruction.scss'],
          'general-js': './src/js/general.js',
          'instruction-js': './src/js/instruction.js'
        },

    // ===== OUTPUT =====
    output: {
      filename: isDev
        ? './js/bundle.js'
        : './js/[name].bundle.js',
      publicPath: '/dist/',
      path: path.resolve(__dirname, 'dist')
    },

    // ===== DEVTOOL =====
    devtool: isDev ? 'eval-source-map' : 'source-map',

    // ===== MODE =====
    mode: argv.mode,

    // ===== OPTIMIZATION =====
    optimization: {
      minimize: isProd,
      minimizer: isProd
        ? [
            new TerserPlugin({
              parallel: true,
              cache: true
            })
          ]
        : [],
      splitChunks: isProd
        ? {
            cacheGroups: {
              defaultVendors: false,
              vendor: {
                test: /[\\/]node_modules[\\/](vue|axios|vue-axios|swiper|imask)[\\/]/,
                name: 'vendor-script',
                chunks: (chunk) =>
                  ['general-js', 'instruction-js', 'instruction-lazy'].includes(
                    chunk.name
                  ),
                enforce: true
              }
            }
          }
        : false
    },

    // ===== PERFORMANCE =====
    performance: {
      hints: false
    },

    // ===== MODULE RULES =====
    module: {
      rules: [
        {
          test: /\.vue$/,
          loader: 'vue-loader'
        },
        {
          test: /\.(sass|scss)$/,
          include: path.resolve(__dirname, 'src/scss'),
          use: [
            {
              loader: MiniCssExtractPlugin.loader
            },
            {
              loader: 'css-loader',
              options: {
                sourceMap: true,
                url: false
              }
            },
            {
              loader: 'postcss-loader',
              options: {
                ident: 'postcss',
                sourceMap: true,
                plugins: () => [
                  require('cssnano')({
                    preset: [
                      'default',
                      {
                        discardComments: {
                          removeAll: true
                        }
                      }
                    ]
                  })
                ]
              }
            },
            {
              loader: 'sass-loader',
              options: {
                sourceMap: true
              }
            }
          ]
        },
        {
          test: /\.pug$/,
          oneOf: [
            {
              include: path.resolve(__dirname, 'src/pug/'),
              exclude: /\.vue$/,
              use: ['pug-loader']
            },
            {
              use: ['pug-plain-loader']
            }
          ]
        },
        {
          enforce: 'pre',
          test: /\.js$/,
          exclude: /node_modules/,
          loader: 'eslint-loader'
        },
        {
          test: /\.js$/,
          exclude: /node_modules/,
          use: {
            loader: 'babel-loader'
          }
        },
        {
          test: /\.js$/,
          enforce: 'pre',
          use: ['source-map-loader']
        },
        // Кэширование только в prod
        ...(isProd
          ? [
              {
                test: /\.js$/,
                use: [{ loader: 'cache-loader' }]
              },
              {
                test: /\.(sass|scss)$/,
                use: [{ loader: 'cache-loader' }]
              }
            ]
          : [])
      ]
    },

    // ===== PLUGINS =====
    plugins: [
      new VueLoaderPlugin(),
      new MiniCssExtractPlugin({
        filename: isDev ? './css/all.css' : './css/[name].css'
      }),
      new CopyWebpackPlugin([
        {
          from: './src/fonts',
          to: './fonts'
        },
        {
          from: './src/img',
          to: './img'
        }
      ])
    ],

    // ===== RESOLVE =====
    resolve: {
      alias: {
        vue: isProd
          ? 'vue/dist/vue.min.js'
          : 'vue/dist/vue.js'
      }
    }
  };

  // ===== HTML Plugins =====
  if (isDev) {
    // Dev: генерируем HTML, но не трогаем скрипты (inject: false)
    config.plugins = config.plugins.concat(generateHtmlPlugins('./src/pug/views'));
  }

  if (isProd) {
    config.plugins.push(new CleanWebpackPlugin());

    // Переименование all.bundle.js → bundle.js
    config.plugins.push({
      apply: (compiler) => {
        compiler.hooks.afterEmit.tap('RenameMainToBundle', () => {
          const mainPath = path.resolve(__dirname, 'dist/js/all.bundle.js');
          const bundlePath = path.resolve(__dirname, 'dist/js/bundle.js');
          if (fs.existsSync(mainPath)) {
            fs.renameSync(mainPath, bundlePath);
            console.log('✅ all.bundle.js → bundle.js');
          }
        });
      }
    });

    // Удаление JS от CSS-only entry
    config.plugins.push({
      apply: (compiler) => {
        compiler.hooks.afterEmit.tap('CleanupCSSOnlyJS', () => {
          const cssOnlyEntries = ['general-style', 'instruction'];
          cssOnlyEntries.forEach((name) => {
            const jsPath = path.resolve(compiler.outputPath, `js/${name}.bundle.js`);
            if (fs.existsSync(jsPath)) {
              fs.unlinkSync(jsPath);
            }
          });
        });
      }
    });

    config.plugins = config.plugins.concat(generateHtmlPlugins('./src/pug/views'));
  }

  return config;
};
