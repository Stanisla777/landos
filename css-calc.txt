receivedDateMobile([year, month]) {
  const dateString = `${year}-${month}`;
  
  // Используем $nextTick + setTimeout для iOS и медленных браузеров
  this.$nextTick(() => {
    setTimeout(() => {
      const container = this.$refs.mobileShedule;
      if (!container) return;

      const element = container.querySelector(`[data-date="${dateString}"]`);
      if (!element) {
        console.warn(`Элемент с data-date="${dateString}" не найден`);
        return;
      }

      // Убедимся, что позиции рассчитаны корректно
      this.$nextTick(() => {
        setTimeout(() => {
          this.scrollToElementSmart(container, element);
        }, 50); // Дополнительная буферизация для iOS
      });
    }, 50);
  });
},

/-----------------------------------------------------------------

scrollToElementSmart(container, targetElement) {
  // Проверка на существование элементов
  if (!container || !targetElement) return;

  // Пересчитываем позиции только сейчас — после всех layout
  const containerRect = container.getBoundingClientRect();
  const targetRect = targetElement.getBoundingClientRect();
  const pageScrollTop = window.scrollY;

  // Позиция элемента относительно контейнера
  const targetTopInContainer = targetRect.top - containerRect.top + container.scrollTop;
  const maxContainerScroll = container.scrollHeight - container.clientHeight;

  // Желаемый скролл контейнера (чтобы элемент был вверху)
  const desiredContainerScroll = Math.max(0, Math.min(targetTopInContainer, maxContainerScroll));

  const canScrollContainer = container.scrollHeight > container.clientHeight;

  if (canScrollContainer) {
    // Скроллим контейнер
    this.smoothScrollTo(container, 'scrollTop', desiredContainerScroll, 300, (val) => {
      container.scrollTop = val;
    });

    // После анимации — подстраиваем страницу, если элемент вне экрана
    setTimeout(() => {
      const finalTargetRect = targetElement.getBoundingClientRect();

      if (finalTargetRect.top < 20 || finalTargetRect.bottom > window.innerHeight - 20) {
        const newPageScrollTop = window.scrollY + finalTargetRect.top - 10;
        this.smoothScrollTo(window, 'scrollY', newPageScrollTop, 300, (val) => {
          window.scrollTo(0, val);
        });
      }
    }, 310);
  } else {
    // Контейнер не скроллится — скроллим страницу
    const targetPageScrollTop = pageScrollTop + targetRect.top - 10;
    this.smoothScrollTo(window, 'scrollY', targetPageScrollTop, 300, (val) => {
      window.scrollTo(0, val);
    });
  }
},

----------------------------------------

Добавить requestAnimationFrame перед getBoundingClientRect()
Это гарантирует, что мы читаем позиции после layout:

// Вместо setTimeout(…, 50), можно использовать в методе receivedDateMobile:
requestAnimationFrame(() => {
  requestAnimationFrame(() => {
    // Теперь точно после layout
    this.scrollToElementSmart(container, element);
  });
});



/-----------------------deepsek
scrollToElementSmart(container, targetElement) {
  // Добавляем небольшую задержку для гарантии обновления layout
  setTimeout(() => {
    const containerRect = container.getBoundingClientRect();
    const targetRect = targetElement.getBoundingClientRect();
    const pageScrollTop = window.scrollY || window.pageYOffset;
    const containerScrollTop = container.scrollTop;

    // Вычисляем позицию элемента относительно контейнера
    const targetTopInContainer = targetRect.top - containerRect.top + containerScrollTop;
    const targetBottomInContainer = targetTopInContainer + targetRect.height;
    
    const containerHeight = container.clientHeight;
    const maxContainerScroll = container.scrollHeight - containerHeight;

    // Проверяем, есть ли скролл у контейнера
    const canScrollContainer = container.scrollHeight > containerHeight;

    if (canScrollContainer) {
      // Вычисляем желаемую позицию скролла контейнера
      let desiredContainerScroll;
      
      // Если элемент выше видимой области
      if (targetTopInContainer < containerScrollTop) {
        desiredContainerScroll = targetTopInContainer;
      } 
      // Если элемент ниже видимой области
      else if (targetBottomInContainer > containerScrollTop + containerHeight) {
        desiredContainerScroll = targetBottomInContainer - containerHeight;
      } 
      // Если элемент уже виден
      else {
        return;
      }

      // Ограничиваем скролл в пределах возможного
      desiredContainerScroll = Math.max(0, Math.min(desiredContainerScroll, maxContainerScroll));

      // Плавный скролл контейнера
      this.smoothScrollTo(container, 'scrollTop', desiredContainerScroll, 300, (val) => {
        container.scrollTop = val;
      });

      // После скролла контейнера проверяем, нужно ли скроллить страницу
      setTimeout(() => {
        const finalTargetRect = targetElement.getBoundingClientRect();
        const viewportHeight = window.innerHeight || document.documentElement.clientHeight;

        // Если элемент все еще не в видимой области viewport
        if (finalTargetRect.top < 0 || finalTargetRect.bottom > viewportHeight) {
          const targetTop = pageScrollTop + finalTargetRect.top - 20; // 20px отступ сверху
          this.smoothScrollTo(window, 'scrollY', targetTop, 300, (val) => {
            window.scrollTo(0, val);
          });
        }
      }, 350);
    } else {
      // Если контейнер не скроллится - скроллим страницу к элементу
      const targetTop = pageScrollTop + targetRect.top - 20; // 20px отступ сверху
      this.smoothScrollTo(window, 'scrollY', targetTop, 300, (val) => {
        window.scrollTo(0, val);
      });
    }
  }, 50); // Небольшая задержка 50ms
},

