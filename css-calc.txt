receivedDateMobile([year, month]) {
  const dateString = `${year}-${month}`;
  this.$nextTick(() => {
    const element = this.$refs.mobileShedule.querySelector(`[data-date="${dateString}"]`);
    if (element) {
      this.smoothScrollToElement(element);
    }
  });
},

async smoothScrollToElement(element) {
  const container = this.$refs.mobileShedule;
  
  // Сначала убедимся, что контейнер виден в viewport
  await this.scrollContainerIntoView(container);
  
  // Затем скроллим внутри контейнера
  await this.scrollElementIntoContainer(element, container);
},

async scrollContainerIntoView(container) {
  const containerRect = container.getBoundingClientRect();
  const viewportHeight = window.innerHeight || document.documentElement.clientHeight;
  
  // Проверяем, виден ли контейнер в viewport
  const isContainerInViewport = 
    containerRect.top >= 0 &&
    containerRect.bottom <= viewportHeight;
  
  if (!isContainerInViewport) {
    // Вычисляем позицию для скролла страницы
    const targetScroll = window.scrollY + containerRect.top - 20;
    await this.animateScroll(window, targetScroll, 400);
  }
},

async scrollElementIntoContainer(element, container) {
  const elementRect = element.getBoundingClientRect();
  const containerRect = container.getBoundingClientRect();
  
  // Вычисляем относительную позицию элемента внутри контейнера
  const relativeTop = elementRect.top - containerRect.top;
  const relativeBottom = elementRect.bottom - containerRect.top;
  
  // Вычисляем целевую позицию скролла
  const containerHeight = container.clientHeight;
  let targetScroll;
  
  if (elementRect.height > containerHeight) {
    // Если элемент больше контейнера, скроллим к его верху
    targetScroll = container.scrollTop + relativeTop;
  } else if (relativeBottom > containerHeight) {
    // Если элемент не помещается снизу, скроллим так чтобы он был внизу
    targetScroll = container.scrollTop + relativeBottom - containerHeight;
  } else if (relativeTop < 0) {
    // Если элемент не помещается сверху, скроллим к его верху
    targetScroll = container.scrollTop + relativeTop;
  } else {
    // Элемент уже виден
    return;
  }
  
  // Добавляем небольшой отступ
  targetScroll -= 20;
  
  await this.animateScroll(container, targetScroll, 500);
},

animateScroll(element, targetPosition, duration) {
  return new Promise(resolve => {
    const startPosition = element.scrollTop || window.scrollY;
    const distance = targetPosition - startPosition;
    let startTime = null;

    const animation = (timestamp) => {
      if (!startTime) startTime = timestamp;
      const progress = timestamp - startTime;
      const percentage = Math.min(progress / duration, 1);

      // Кубическая easing функция для плавности
      const easing = t => t<.5 ? 4*t*t*t : (t-1)*(2*t-2)*(2*t-2)+1;
      const scrollNow = startPosition + (distance * easing(percentage));

      if (element === window) {
        window.scrollTo(0, scrollNow);
      } else {
        element.scrollTop = scrollNow;
      }

      if (progress < duration) {
        window.requestAnimationFrame(animation);
      } else {
        resolve();
      }
    };

    window.requestAnimationFrame(animation);
  });
}
