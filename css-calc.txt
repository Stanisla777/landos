numberFormattingThousandths(count, e) {
  const target = e.target;
  let position = target.selectionStart;

  // ðŸ”¥ Ð‘ÐµÑ€Ñ‘Ð¼ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ðµ Ð˜Ð— Ð¡ÐžÐ‘Ð«Ð¢Ð˜Ð¯, Ð° Ð½Ðµ Ð¸Ð· this.dataFieldIncome!
  let rawValue = e.target.value;

  // Ð£Ð±Ð¸Ñ€Ð°ÐµÐ¼ Ð²ÑÑ‘, ÐºÑ€Ð¾Ð¼Ðµ Ñ†Ð¸Ñ„Ñ€, Ñ‚Ð¾Ñ‡ÐºÐ¸ Ð¸ Ð·Ð°Ð¿ÑÑ‚Ð¾Ð¹
  let cleaned = rawValue.replace(/[^\d.,]/g, '');

  // Ð•ÑÐ»Ð¸ ÑÑ‚Ñ€Ð¾ÐºÐ° Ð¿ÑƒÑÑ‚Ð°Ñ â€” ÑÐ±Ñ€Ð°ÑÑ‹Ð²Ð°ÐµÐ¼
  if (cleaned === '') {
    this.dataFieldIncome = '';
    return;
  }

  // Ð—Ð°Ð¼ÐµÐ½ÑÐµÐ¼ Ð·Ð°Ð¿ÑÑ‚ÑƒÑŽ Ð½Ð° Ñ‚Ð¾Ñ‡ÐºÑƒ Ð´Ð»Ñ Ð¿Ð°Ñ€ÑÐ¸Ð½Ð³Ð°
  let normalized = cleaned.replace(/,/g, '.');

  // Ð Ð°Ð·Ð´ÐµÐ»ÑÐµÐ¼ Ð½Ð° Ñ‡Ð°ÑÑ‚Ð¸
  let parts = normalized.split('.');
  let integerPart = parts[0] || '0';
  let decimalPart = parts[1] ? parts[1].slice(0, 2) : '';

  // Ð¡Ð¾Ð±Ð¸Ñ€Ð°ÐµÐ¼ Ñ‡Ð¸ÑÐ»Ð¾
  let numericStr = decimalPart ? `${integerPart}.${decimalPart}` : integerPart;
  let num = Number(numericStr);

  // Ð—Ð°Ñ‰Ð¸Ñ‚Ð° Ð¾Ñ‚ NaN
  if (isNaN(num)) {
    // Ð’Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ð¾, Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÑŒ Ð²Ð²Ñ‘Ð» Ñ‚Ð¾Ð»ÑŒÐºÐ¾ ",", Ñ‚Ð¾Ð³Ð´Ð° ÑÐ¾Ñ…Ñ€Ð°Ð½ÑÐµÐ¼ "0,"
    if (cleaned === ',' || cleaned === '.') {
      this.dataFieldIncome = '0,';
      this.$nextTick(() => {
        target.setSelectionRange(2, 2); // Ð¿Ð¾ÑÐ»Ðµ "0,"
      });
      return;
    }
    this.dataFieldIncome = '';
    return;
  }

  // ÐžÐ³Ñ€Ð°Ð½Ð¸Ñ‡ÐµÐ½Ð¸Ðµ Ð¿Ð¾ Ð¼Ð°ÐºÑÐ¸Ð¼ÑƒÐ¼Ñƒ
  if (num > count) {
    num = count;
    num = Math.round(num * 100) / 100;
  }

  // Ð¤Ð¾Ñ€Ð¼Ð°Ñ‚Ð¸Ñ€ÑƒÐµÐ¼
  const formatter = new Intl.NumberFormat('ru-RU', {
    minimumFractionDigits: decimalPart ? decimalPart.length : 0,
    maximumFractionDigits: 2
  });

  this.dataFieldIncome = formatter.format(num);

  // Ð’Ð¾ÑÑÑ‚Ð°Ð½Ð°Ð²Ð»Ð¸Ð²Ð°ÐµÐ¼ ÐºÑƒÑ€ÑÐ¾Ñ€ (Ð¿Ñ€Ð¾ÑÑ‚Ð¾Ð¹ Ð²Ð°Ñ€Ð¸Ð°Ð½Ñ‚ â€” Ð² ÐºÐ¾Ð½ÐµÑ†)
  this.$nextTick(() => {
    target.setSelectionRange(this.dataFieldIncome.length, this.dataFieldIncome.length);
  });
}
